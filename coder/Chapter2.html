<!DOCTYPE html>
<html>
  <head>
    <title>2 – Plugin logger</title>
  </head>
  <body text=#000000 bgcolor=#FFFFFF link=#0000FF alink=#0000FF vlink=#0000FF>
    <link rel="stylesheet" href="styles.css"/>
    <script src="copycode.js"></script>
    <h1>Plugin logger, error handling and debugging features</h1>
    <table width=100%>
      <tr>
      <td><a href="Chapter1_5.html"><strong>&lt;&lt;&lt;&nbsp;PREV</strong></a></td>
      <td style="text-align: right"><a href="Chapter3.html" ><strong>NEXT&nbsp;&gt;&gt;&gt;</strong></a></td>
      </tr>
    </table><br>
    When writing code, there is always a high chance of making mistakes. Sometimes, this can be simply due to a lack of knowledge about the language or a feature, but not always. In reality, it happens to the best of us. It’s easy to overlook something when working with text on the screen. Often, we are tired after a long day, or we are in dire need of a break after focusing on a task for an extended period of time, and sooner or later we end up making a mistake. Not a big deal, either way!<br><br>
    Regardless of the reason for the mistake, programming languages like Lua are rather strict with what is and what isn’t accepted (even more strict than natural languages, like English, Spanish or Japanese), leaving little room for leniency. Whether it’s a problem with Lua syntax, or giving something the wrong type of value, or some other unexpected occurence in code, the plugin will complain about it in the form of an <strong>error message</strong>, letting the coder know what went wrong, in which Lua file and in which line it happened. Where do we encounter this special route of communication, though? We have not seen such error messages as of yet. Well, that is because they are sent to the <strong>plugin’s logging system</strong>, which is not enabled by default and must be enabled manually as a main plugin setting (MPS) flag for the Particle System plugin.<br><br>
    In this chapter, we will learn about the plugin’s logger and how to enable it. We’ll discover the different types of log messages and their meanings. We’ll get to know the error handling system and understand how to decipher the various error messages the plugin can give us. Finally, we’ll learn how to use the <span class="var">print()</span> function to help with narrowing down silent bugs in the code. Although this chapter may be more of a dry read compared to the exciting previous chapter, learning about these very useful functionalities of the plugin will be a tremendous help, especially once we start tackling update functions in Chapter 3 and other more complex features further on.<br>
    <hr>
    <h2>Sections</h2>
    <strong>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id1">1. The plugin logger</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id2">2. How to enable the logger</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id3">3. Filtering out log messages</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id4">4. Error handling in the plugin</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id5">5. Fixing warning and error messages</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id6">6. Using the print() function for debugging</a><br>
    </strong>
    <hr>
    <a name="id1"><h3>The plugin logger</h3></a>
    The logger is an indispensable tool to have once you start to experiment more with the Particle System plugin and its scripting on your own. It not only reports any warnings or errors of things going wrong in your Lua code, but can give other useful infos about the internal processes going on in the plugin. Last but not least, it provides a reliable way to debug your modules and verify if your code works as intended.<br><br>
    The logger is built into <span class="var">Plugin_ParticleSystem.dll</span> and can display 4 categories of log messages:<br><br>
    <table cellpadding = "15" cellspacing = "15" class="tab">
      <tr>
        <th>Message&nbsp;Type</th>
        <th>Use and Meaning</th>
      </tr>
      <tr>
        <td><span class="var">INFO</span></td>
        <td>Logs more detailed information about plugin-side operations, e.g. that a specific level script or module was loaded.</td>
      </tr>
      <tr>
        <td><span class="var">DEBUG</span></td>
        <td>Logs debug output from the <span class="var">print()</span> function (explained further in this chapter).</td>
      </tr>
      <tr>
        <td><span class="var">WARN</span></td>
        <td>Logs warnings – not quite errors yet, but alerts of some improper input (e.g. value not in range), that the plugin can rectify by itself. However, relying on the plugin may hamper performance and it’s recommended to fix these warnings in final code whenever possible.</td>
      </tr>
      <tr>
        <td><span class="var">ERROR</span></td>
        <td>Logs errors – alerts of something going terribly wrong, e.g. improper Lua syntax, assigning the incorrect type value to a field, missing a necessary function argument. These errors cause the Lua environment to abort executing the script code and they must be fixed to resume normal operation.</td>
      </tr>
    </table>
    <br><br>
    The <span class="var">INFO</span> messages are only for providing extra context and can be safely ignored for the most part. In fact, there is a setting to filter them out if they prove distracting, which will be described further down this chapter. <span class="var">DEBUG</span> messages arise due to user activity, coming from the use of the <span class="var">print()</span> debugging function, which we will also cover later. The main group of messages relevant to coders are <span class="var">WARN</span> and <span class="var">ERROR</span>. With these message types, the plugin gives explicit indications of something not going right with a module or level script, hence they should be paid attention to. Given that these messages can be rather cryptic if you don’t know how to read them, this chapter also holds a section dedicated to interpreting examples of these messages and what actions you should carry out, in order to correct the module or level script code.<br><br>
    <h4>Modes of operation</h4>
    The logger is disabled by default, but can be manually enabled in one of two modes of operation:
    <ol>
      <li><strong>Console mode</strong></li>
      <li><strong>File-dump mode</strong></li>
    </ol>
    Let’s take a look at the console mode first, then we’ll examine the file-dump mode.<br><br>
    <h4>Console mode</h4>
    The <strong>Console mode</strong> of the logger makes the game open a secondary window during boot, hosting an output console which displays the log messages from the plugin:
    <img src="ch2/logger_console.png" class="fig"><br>
    Various log messages are displayed in the console window in real-time, while the game is running. This can give you <u>real-time feedback</u> as to what is going on, and allows to track down when a specific log entry or error occurs.<br><br>
    In console mode, the log messages are color-coded with the following scheme:<br><br>
    <table cellpadding = "15" cellspacing = "15" style="color: white; background-color: black; font-family: 'Consolas'; font-size: 90%">
      <tr>
        <td><span style="color: white">INFO</span> (white)</td>
      </tr>
      <tr>
        <td><span style="color: lime">DEBUG</span> (green)</td>
      </tr>
      <tr>
        <td><span style="color: yellow">WARN</span> (yellow)</td>
      </tr>
      <tr>
        <td><span style="color: red">ERROR</span> (red)</td>
      </tr>
    </table><br><br>
    When enabling the console log mode, it is <u>strongly recommended</u> to also switch on <strong>windowed mode</strong> in the configuration settings of the game (the config window is displayed by holding <strong>CTRL</strong> before the game launches), or at the very least, use the <strong>Soft Full Screen</strong> setting. I’m aware it’s annoying to switch between different config settings during building, however in the course of testing the plugin across different PCs, there were hangs, crashes or otherwise odd behavior, when the console window was enabled and the game remained in proper fullscreen mode. You can of course return to the normal fullscreen setting once you no longer use the console logger.<br><br>
    <h4>File-dump mode</h4>
    The <strong>File-dump mode</strong> works differently. Instead of logging the messages to a separate console window, it <strong>dumps</strong> the logs to a newly generated text file each time the game is booted. This file is named with the general scheme:
    <div class="code">
      Plugin_ParticleSystem_YYYYMMDD_HHMMSS_log.txt
    </div>
    Where <span class="var">YYYYMMDD</span> stands for the current date, and <span class="var">HHMMSS</span> stands for the current system time on the PC, registered when the game is booted. These log files become available only after the game is closed and can be found in the working directory, where the <span class="var">Plugin_ParticleSystem.dll</span> is present, alongside <span class="var">tomb4.exe</span>. Though file dump logs do not allow to investigate the plugin behavior in real time, they are a more durable form of registering the plugin activity, which can later be examined at any time, or sent over to someone else (e.g. the plugin devs, in case of a suspected plugin bug). These text file logs are preferable to screenshots from the log console in such cases, as they give direct access to the text of each log message in chronological order. Here is a snippet showing example contents of a log text file:
    <div class="code"><span class="com">
      INFO: Loading scripts of level: Playable Tutorial Level<br>
      INFO: Loading module: dust<br>
      WARN: modulescripts\dust.lua:55: -1 is less than the minimum of 0, clamping to minimum<br>
      stack traceback:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;modulescripts\dust.lua:55: in main chunk<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[C]: in global 'require'<br>
      &nbsp;&nbsp;&nbsp;&nbsp;levelscripts\tut1.lua:107: in main chunk<br>
      DEBUG: Test string after loading module 'dust'<br>
      INFO: Loading module: burn<br>
      ERROR: levelscripts\karnak.lua:8: attempt to access inexistent field 'damage'<br>
      stack traceback:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[C]: in metamethod 'newindex'<br>
      &nbsp;&nbsp;&nbsp;&nbsp;levelscripts\karnak.lua:8: in main chunk<br>
      ERROR: cannot load 'temple' level script<br>
      stack traceback:<br>
      ERROR: modulescripts\burn.lua:95: Vector3f expected<br>
      stack traceback:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[C]: in global 'soundEffect'<br>
      &nbsp;&nbsp;&nbsp;&nbsp;modulescripts\burn.lua:95: in function &lt;modulescripts\burn.lua:74&gt;
    </span>
    </div>
    File-dump logs do not have color-coding as in the console (since they are dumped to a plain-text file), but still retain appropriate tags in the first line, which inform of the category of the given message.<br>
    <hr>
    <a name="id2"><h3>How to enable the logger</h3></a>
    By default, the logger of the Particle System plugin is not enabled. You must enable it manually.<br><br>
    The logger is enabled with special <span class="var">MPS_</span> flag constants understood by the Particle System plugin. There are two such flags:
    <ol>
      <li><span class="var">MPS_LOGGER_CONSOLE</span></li>
      <li><span class="var">MPS_LOGGER_FILE</span></li>
    </ol>
    As you might guess, the first enables the <strong>console mode</strong> of the logger, while the second enables the <strong>file-dump mode</strong>. These constants should be placed in the <span class="var">Plugin=</span> command that gets added to <span class="var">script.txt</span> in the <span class="var">[Options]</span> section, when installing the plugin through <strong>TombIDE</strong> or <strong>NG Center</strong>. For example, the plugin command for <span class="var">Plugin_ParticleSystem</span> could be:
    <div class="code">
      Plugin= 1, Plugin_ParticleSystem, IGNORE
    </div>
    If you have other plugins installed, the ID (first number) for <span class="var">Plugin_ParticleSystem</span> could be different, but it does not matter (and you shouldn’t change this number yourself, anyway). To enable the one of the logger modes, you add the desired <span class="var">MPS_</span> constant in place of the default <span class="var">IGNORE</span>:
    <div class="code">
      Plugin= 1, Plugin_ParticleSystem, MPS_LOGGER_CONSOLE
    </div>
    or
    <div class="code">
      Plugin= 1, Plugin_ParticleSystem, MPS_LOGGER_FILE
    </div>
    You can have <u>only one</u> logger mode active at once. You are not allowed to enable both, e.g. the following <u>does not</u> work: <span class="var">MPS_LOGGER_CONSOLE + MPS_LOGGER_FILE</span>. Of course, for the chosen <span class="var">MPS_</span> flag to take effect, you must rebuild the script before booting the game.<br><br>
    <h4>Disabling the logger</h4>
    Once you no longer want to use the logger, you can switch it off by restoring the plugin command in <span class="var">[Options]</span> to its initial state, without any <span class="var">MPS_</span> flags:
    <div class="code">
      Plugin= 1, Plugin_ParticleSystem, IGNORE
    </div>
    If you are also a level builder, preparing a TRLE release, you should <u>always turn off</u> the logger for the release version of the TRLE project, as it is a tool for coders and possibly builders. The players, on the other hand, should not (and likely do not want to) see it. The console is rather distracting and tends to make the game engine less stable, while the log files add unnecessary trash to the game folder.
    <hr>
    <a name="id3"><h3>Filtering out log messages</h3></a>
    As mentioned before, the plugin provides a total of 4 log message categories: <span class="var">INFO, DEBUG, WARN, ERROR</span>. However, some categories of messages are more important than others. For instance, <span class="var">INFO</span> mainly provides extra context of what the plugin was doing, before a warning or error occured. But you may decide to ignore this message category altogether and focus on just the <span class="var">WARN</span> and <span class="var">ERROR</span> messages. If you want to filter out which messages are allowed to appear in the logger, you can do so with a special API function, <span class="var">setLogLevel()</span>.<br><br>
    The <span class="var">setLogLevel()</span> function accepts special <span class="var">LOG_</span> constants, which filter out certain categories of messages. Log message categories are ordered by importance rank, according to the table below (higher number means higher importance):<br><br>
    <table cellpadding = "15" cellspacing = "15" class="tab">
      <tr>
        <th>Message Type</th>
        <th>Importance Rank</th>
        <th>LOG_ constant</th>
      </tr>
      <tr>
        <td><span class="var">INFO</span></td>
        <td><span class="var">1</span></td>
        <td><span class="var">LOG_INFO</span></td>
      </tr>
      <tr>
        <td><span class="var">DEBUG</span></td>
        <td><span class="var">2</span></td>
        <td><span class="var">LOG_DEBUG</span></td>
      </tr>
      <tr>
        <td><span class="var">WARN</span></td>
        <td><span class="var">3</span></td>
        <td><span class="var">LOG_WARN</span></td>
      </tr>
      <tr>
        <td><span class="var">ERROR</span></td>
        <td><span class="var">4</span></td>
        <td><span class="var">LOG_ERROR</span></td>
      </tr>
    </table><br><br>
    The way <span class="var">LOG_</span> constants work is that they permit categories of importance <u>higher or equal to</u> the message category they specify. E.g. <span class="var">LOG_INFO</span> permits all message categories (1-4), <span class="var">LOG_WARN</span> permits only messages of importance 3 or higher (3-4), while <span class="var">LOG_ERROR</span> will only permit <span class="var">ERROR</span> messages (4).<br><br>
    By default, when a game is newly booted, the message filtering level is set to <span class="var">LOG_INFO</span> (i.e. no filtering). To set a different level, you call <span class="var">setLogLevel()</span> with the appropriate <span class="var">LOG_</span> constant in Lua:
    <div class="code">
      setLogLevel(LOG_DEBUG) <span class="com">-- sets the filtering to permit DEBUG, WARN and ERROR messages</span>
    </div>
    Most often, you will set the log level at the topmost line of a level script. The log level setting is never changed as long as the game is booted, until you change it again, somewhere else. This means that log level settings persist across different levels and in the title menu, from since when they were last modified.<br><br>
    My personally recommended log level setting, if you do not care to receive <span class="var">INFO</span> messages, is <span class="var">LOG_DEBUG</span>. <span class="var">DEBUG</span> messages are only generated due to <span class="var">print()</span> function calls and do not occur otherwise. Meanwhile, <span class="var">WARN</span> and <span class="var">ERROR</span> messages are also permitted by this level, and these messages should not be dismissed, in my opinion. They give important alerts to issues or syntax problems with your Lua code, hence disabling them is not a good idea (you cannot even disable <span class="var">ERROR</span> messages, since the underlying issue makes the Lua environment halt, indicating something that needs immediate addressing).<br>
    <hr>
    <a name="id4"><h3>Error handling in the plugin</h3></a>
    Because you have much freedom to do as you please in script files, there is also plenty of opportunities to make mistakes that Lua will not like. Not all of these mistakes are equal, though, as some are more severe than others. Whichever message category you receive, reading and comprehending the logger output is always the key first step in fixing them. The most important messages to pay attention to in the logger are <span class="var">WARN</span> and <span class="var">ERROR</span> messages. They signal that something is off in the Lua scripts, which needs to be checked and fixed by the coder. When the plugin sends one of these two messages categories to the logger, we say that it <strong>throws</strong> a message (e.g. throws a <span class="var">WARN</span>, throws an <span class="var">ERROR</span>).<br><br>
    These types of messages will usually (but not always!) specify the name of the  <span class="var">.lua</span> file (could be a level script or module script) in which the problem was encountered. It may also specify the particular line of the script file where the problem occurred (counting from the top – starting from line 1). However, the messages can be a bit confusing if you don’t know what you’re supposed to look for in the message. This section will teach you how you should interpret these messages and understand what the plugin is trying to tell you in the process.<br><br>
    There is a general structure to <span class="var">WARN</span> and <span class="var">ERROR</span> message types:
    <div class="code">
      [TAG]: [filepath]:[line number]: [message]<br>
      stack traceback:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[traceback 1]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[traceback 2]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;.<br>
      &nbsp;&nbsp;&nbsp;&nbsp;.<br>
      &nbsp;&nbsp;&nbsp;&nbsp;.<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[traceback N]<br>
    </div>
    Here is a concrete example, an <span class="var">ERROR</span> message that occured on line 8 of <span class="var">karnak.lua</span> level script:
    <div class="code" style="color: red">
      ERROR: levelscripts\karnak.lua:8: attempt to access inexistent field 'damage'<br>
      stack traceback:<br>
	    &nbsp;&nbsp;&nbsp;&nbsp;[C]: in metamethod 'newindex'<br>
	    &nbsp;&nbsp;&nbsp;&nbsp;levelscripts\karnak.lua:8: in main chunk<br>
    </div>
    The <span class="var">[TAG]</span>, e.g. <span class="var">ERROR</span>, tells the message category. The <span class="var">[filepath]</span> describes in which file the issue was encountered, e.g. <span class="var">levelscripts\karnak.lua</span> indicates this happened in the <span class="var">karnak.lua</span> file in the <span class="var">levelscripts</span> folder. After the colon comes the <span class="var">[line&nbsp;number]</span>, in this case line number <span class="var">8</span> (the first line in a file is line 1 and you count downwards, but if you use Nodepad++, by default it displays the line numbers on the left gutter). These are the most important parts of the log message to pay attention to.<br><br>
    The next part of the message, below the tag line, is something called a <strong>stack traceback</strong> – it is a list of all functions called before the faulty line was reached, in reverse order (top is most recent, bottom is oldest). How many of these traceback lines are in a message will vary depending on the complexity of the script, but generally 1 to 3 lines is what you will encounter most often. Such traceback lines provide additional context, but in practice will be mostly useful to people with prior programming experience (since tracebacks are frequently examined in the process of debugging code). For a casual particle coder though, the most important information is already stated in the first line, above the traceback (i.e. the message category, the file path, the line number and the message contents).<br><br>
    After receiving a <span class="var">WARN</span> or <span class="var">ERROR</span> message, what should we do? First of all, we shouldn’t panic. We start by opening the file indicated in the tag line of the message, if not already opened. We navigate to the line number specified after the file name and examine the code on that line, to see if we can connect the dots and infer what went wrong in our code. The next section gets into the specifics of how to continue from there.<br>
    <hr>
    <a name="id5"><h3>Fixing warning and error messages</h3></a>
    Although receiving a warning or error in the logger may seem intimidating at first, the plugin is actually just trying to help you here. Interpreting the message correctly is important for understanding how to resolve any problems which resulted in the warning or error. This section will discuss <span class="var">WARN</span> and <span class="var">ERROR</span> message types, detailing in which circumstances you may encounter these messages and what you can do to fix or remove the issue that made the message appear.<br><br>
    <h4>WARN messages</h4>
    As a reminder, <span class="var">WARN</span> messages have the least concerning implications of the two. They signal that something is somewhat incorrect, but not in a way which would stop the plugin in its tracks. After the plugin throws a <span class="var">WARN</span> message, it can usually make some quick adjustment by itself, to work around the faulty value or otherwise minor issue. However, it cannot step in and fix the already written code on its own, so it will often keep churning out these warnings, each time the faulty piece of code is executed. This can lead to a spammed logger, with hundreds of <span class="var">WARN</span> messages:
    <img class="fig" src="ch2/warning1.png"><br>
    Of course, throwing a message and side-stepping the issue comes at a cost, it’s extra work the plugin has to do. It takes computing resources away from what would otherwise be flawless execution of Lua code, and this may make the script’s performance worse. Hence, it is strongly recommended to fix warnings whenever possible, instead of relying on the plugin to step in. We’re responsible adults, aren’t we? The good news is fixing warnings is usually trivial.<br><br>
    There are two common reasons for which you’ll receive <span class="var">WARN</span> messages in the logger:
    <ul>
      <li>if a value was assigned to a field: it is not in the appropriate range of expected values, but still matches the expected type (e.g. a number outside of range <span class="var">[0, 255]</span> accepted for the field)</li>
      <li>if a value was given to a function argument: it is not in the appropriate range of expected values, but still matches the expected type (e.g. a number outside of range <span class="var">[-32768, 32767]</span> accepted for the argument)</li>
    </ul>
    In these cases, after sending the <span class="var">WARN</span> message, the plugin will fall back on some appropriate default value and proceed with execution, which makes the consequences less damning. But according to our agreement, we should still fix these issues, right? Good, so let’s examine each of the above <span class="var">WARN</span> scenarios and learn how to avoid it or fix it, if it occurs.<br><br>
    <h4>Assigning an out-of-range value to a field</h4>
    If there is an assignment of a value to a field, check what you are actually assigning to it. If you are aware of the range of acceptable values for a field and you are explicitly assigning a value outside that range, it’s quite easy to catch. A good example for restricted field values are the <span class="var">r, g, b</span> color components of <span class="var">ColorRGB</span>, which allow values only from <span class="var">0</span> to <span class="var">255</span>. If you have something like the following:
    <div class="code">
      part.colStart.r = 355
    </div>
    Then it’s very obvious that such an assignment is invalid, exceeding the maximum. The plugin will complain, via a <span class="var">WARN</span> message (likely several times over):<br>
    <img class="fig" src="ch2/warning2.png"><br>
    And then, reduce the value by itself to <span class="var">255</span>.<br><br>
    However, sometimes it is not immediately clear by just reading the script, whether the assigned value is out of range or not (e.g. because it was obtained from a variable, expression or function). To illustrate this, let’s assume we have a mysterious function <span class="var">func(x)</span>, of which we know nothing, except that it returns number values. We are not sure of the minimum or maximum possible value this function can give (there may be no maximum, if the function keeps rising towards infinity, for example). Perhaps against our better judgement, we decide to assign the result of calling <span class="var">func(x)</span> for <span class="var">x = 10</span>, to the <span class="var">part.colStart.r</span> field:
    <div class="code">
      local x = 10 <span class="com">-- some arbitrary argument value x</span><br>
      part.colStart.r = func(x) <span class="com">-- calling func(x) and assigning the returned value to colStart.r</span>
    </div>
    But in this hypothetical situation we are entertaining, it turns out that at <span class="var">x = 10</span>, the return value of <span class="var">func(x)</span> will be <span class="var">1000</span>, not good! We later may discover that <span class="var">func(x)</span> has a more suitable value at <span class="var">x = 8</span>, giving <span class="var">200</span>, so we change the value of <span class="var">x</span> to <span class="var">8</span> instead:
    <div class="code">
      local x = 8<br>
      part.colStart.r = func(x)
    </div>
    This would fix the warning if <span class="var">x</span> never changes. However, what if <span class="var">x</span> is not a constant value? As an example:
    <div class="code">
      local x = getGameTick()<br>
      part.colStart.r = func(x)
    </div>
    Here, <span class="var">x</span> takes the current game tick value, so in a sequence of several frames, it will be: <span class="var">0, 1, 2, …, 8, 9, <u>10</u>, 11, …</span> and we don’t know how <span class="var">func(x)</span> behaves as the value of <span class="var">x</span> keeps changing – it may keep rising, but it may start falling down again, who knows (unless you understand the mathematics done by the function, you will not have the foresight to tell). All we know is that for  <span class="var">x = 10</span>, the mystery function <span class="var">func(x)</span> goes out of range for the <span class="var">part.colStart.r</span> field. How do we make the code invulnerable to values out of range? Well, we need to check if the value returned by <span class="var">func(x)</span> is suitable, and then decide to assign it or not:
    <div class="code">
      local x = getGameTick()<br>
      local red = func(x)<br>
      if red <= 255 then <span class="com">-- if red is smaller or equal to upper bound (255) of colStart.r</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = red<br>
      end
    </div>
    This will protect us from assigning a value larger than <span class="var">255</span> to <span class="var">part.colStart.r</span>, if <span class="var">func(x)</span> returned something bigger. However, we may also proceed to assign the upper bound value, in the case that it was indeed bigger. We can use an else branch on the if statement to achieve that:
    <div class="code">
      local x = getGameTick()<br>
      local red = func(x)<br>
      if red <= 255 then <span class="com">-- if res is smaller or equal to upper bound (255) of colStart.r</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = red<br>
      else <span class="com">-- otherwise if it is bigger</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = 255<br>
      end
    </div>
    We have covered the situation where the function surpasses the maximum accepted value. But we later discover another thing about the behavior of <span class="var">func(x)</span>. At <span class="var">x = 5</span>, the returned value is <span class="var">-100</span>. We have a very similar problem as before, except now the value goes beyond the lower bound of <span class="var">0</span>. To remedy it, we could expand the if condition, like so:
    <div class="code">
      local x = getGameTick()<br>
      local red = func(x)<br>
      if red >= 0 and red <= 255 then <span class="com">-- if red is between 0 and 255</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = red<br>
      elseif red > 255 then <span class="com">-- otherwise if red is above 255</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = 255<br>
      else <span class="com">-- otherwise if red is below 0</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = 0<br>
      end<br>
    </div>
    This covers all bases: if the value of <span class="var">red</span> is below the minimum (<span class="var">0</span>), if it’s in range (<span class="var">[0, 255]</span>) or if it’s above the maximum (<span class="var">255</span>) for <span class="var">part.colStart.r</span>. But let’s be honest, this whole ordeal every time we want the assigned value to be restricted to some range is very tedious. Not to mention making our code bloated and more difficult to read. Surely, there should be an easier way to achieve the same thing. Luckily, it exists in the form of the built-in <span class="var">clamp()</span> function.<br><br>
    <a name="clamp"><h4>The clamp() function</h4></a>
    The <span class="var">clamp()</span> function takes three arguments:
    <div class="code">
      clamp(x, min, max)
    </div>
    these arguments are:
    <ol>
      <li><span class="var">x</span> – the input value to be clamped (number)</li>
      <li><span class="var">min</span> – the minimum value to clamp to (number)</li>
      <li><span class="var">max</span> – the maximum value to clamp to (number)</li>
    </ol><br>
    The function will return the value of <span class="var">x</span> if it is within the <span class="var">[min, max]</span> range, otherwise it returns either the <span class="var">min</span> or <span class="var">max</span> value, if the range is exceeded.<br><br>
    The idea of the <span class="var">clamp()</span> function is to replace the multiline if-elseif-else code we have seen above with a single function call:
    <div class="code">
      local x = getGameTick()<br>
      local red = func(x)<br>
      part.colStart.r = clamp(red, 0, 255) <span class="com">-- clamp red to range [0, 255]</span>
    </div>
    thus replacing that multi-branched conditional statement with just one line of code. Really convenient!<br><br>
    <h4>Avoiding out-of-range function arguments</h4>
    We can also use <span class="var">clamp()</span> when a function argument accepts numeric values restricted only to a certain range. Passing arguments that are out of range is another common source of <span class="var">WARN</span> or <span class="var">ERROR</span> messages.<br><br>
    Continuing the theme, we will examine the <span class="var">createColor(r, g, b)</span> function, which creates a ColorRGB data object (that can then be assigned to <span class="var">part.colStart</span>, for example). Similarly to assigning values to the individual RGB color components, the <span class="var">r,&nbsp;g,&nbsp;b</span> arguments of <span class="var">createColor()</span> are restricted to the <span class="var">[0, 255]</span> range.<br><br>
    If we suspect the value we give to an argument may exceed the range, it is safer to clamp it:
    <div class="code">
      local x = getGameTick()<br><br>
      local red = clamp(func(x), 0, 255)<br>
      local green = clamp(func(x + 1), 0, 255)<br>
      local blue = clamp(func(x + 2), 0, 255)<br><br>
      part.colStart = createColor(red, green, blue)
    </div>
    The duty of providing appropriate values falls on us, but this is exactly what a responsible coder would do!<br><br>
    Avoiding script issues is not the only usage for <span class="var">clamp()</span>, of course. It’s a quite useful utility function to have in your toolset, whenever you need to restrict some number value to a predetermined range, for any kind of reason.<br><br><br>
    <h4>ERROR messages</h4>
    Higher on the severity scale are <span class="var">ERROR</span> messages. They indicate a more serious issue than just a mere warning would. Due to the very high importance, <span class="var">ERROR</span> messages are always reported and you cannot turn them off, because they indicate a bigger problem with the code or the scripts in general. When an <span class="var">ERROR</span> message is thrown, the plugin halts all further execution of Lua code, beyond the line in which it occured. Furthermore, it will not load any more level scripts or modules, until the underlying issue is fixed or remedied.<br><br>
    Reasons for <span class="var">ERROR</span> messages are plentiful can arise due to the following circumstances:
    <ul>
      <li>not following general rules of Lua syntax:<br><br>
        <ul style="list-style-type: circle">
          <li>using a <a href="LuaManual.html#keywords">reserved keyword</a> as a variable (or function) name</li>
          <li>not matching up parentheses <span class="var">()</span> (in an expression, a function definition or function call) or <span class="var">[]</span> (indexing brackets) or <span class="var">{}</span> (table brackets)</li>
          <li>not following an if conditional statement with <span class="var">then</span> keyword, i.e. <span class="var">if (condition) then</span></li>
          <li>not following correct for loop statement structure, i.e. <span class="var">for var = start, stop do</span></li>
          <li>not terminating a code block (if-block, for-block, function definition block) with <span class="var">end</span> keyword</li>
          <li>having an expression that cannot be correctly parsed by Lua, e.g. <span class="var">local myvar = ()</span>&nbsp;&nbsp;→&nbsp;&nbsp;no parsable value inside the parentheses (different from <span class="var">{}</span>, indicating an empty table value)</li>
          <li>attempting an arithmetic operation on <a href="LuaManual.html#types">data types</a> that do not support it, e.g. <span class="var">false + "text"</span></li>
          <li>indexing a value that cannot be indexed, e.g. <span class="var">true[5]</span></li>
          <li>calling a value that cannot be called, e.g. <span class="var">"text"()</span></li>
        </ul>
      </li><br>
      <li>using a variable that wasn’t declared as <span class="var">local</span> prior to use (such variables are <a href="LuaManual.html#locals">treated as globals</a>, which are forbidden in the plugin’s Lua environment)</li>
      <li>incorrectly indexing a plugin data entity, e.g. <span class="var">part[10]</span></li>
      <li>attempting to call a plugin data entity as a function, e.g. <span class="var">part()</span></li>
      <li>accessing a non-existing field of a plugin data entity, e.g. <span class="var">part.hitPoints</span></li>
      <li>assigning to a read-only field of a plugin data entity, e.g. <span class="var">part.t = 0.5</span></li>
      <li>assigning a value of incorrect <a href="LuaManual.html#types">data type</a> to a plugin data field, e.g. <span class="var">part.lifeSpan = "text"</span></li>
      <li>passing a value of incorrect data type to a function argument, e.g. <span class="var">randomNegate("text")</span></li>
      <li>passing an otherwise unacceptable argument value to a built-in function</li>
      <li>not passing all necessary arguments to a function, e.g. <span class="var">createColor(192, 128)</span></li>
      <li>indexing a built-in function in any way, e.g. <span class="var">createSpritePart[3]</span> or <span class="var">createGroup.x</span>
      <li>attempting to reassign a built-in function, e.g. <span class="var">degToRad = myfunction</span></li>
    </ul><br>
    Furthermore, there are two additional sources of <span class="var">ERROR</span> messages. They are not caused by something inherently wrong in the Lua files themselves, but arise due to missing files:
    <ul>
      <li>a level script file referenced by the <span class="var">CUST_LEVEL_SCRIPTS</span> command is missing from <span class="var">levelscripts</span> folder</li>
      <li>a module script file referenced by the <span class="var">require()</span> function is missing from <span class="var">modulescripts</span> folder</li>
    </ul><br>
    As you see yourself, there is a lot that can go wrong in scripts which would result in an <span class="var">ERROR</span> message. Fortunately, none of these issues are unfixable.<br><br>
    <h4>Fixing script errors</h4>
    When you receive such an <span class="var">ERROR</span> message, you should follow the same approach as with <span class="var">WARN</span> messages (going to the faulty line in the script and inspecting the code there). The main difference is that while a <span class="var">WARN</span> permits continued operation, a single <span class="var">ERROR</span> occurence will terminate all further execution of code. If there are multiple faulty lines of code, which would result in an <span class="var">ERROR</span>, the plugin only reports the first one it encountered. This means that the next <span class="var">ERROR</span> report will occur only after the previous one is fixed, requiring you to retest the execution of the script and pay close attention to the logged messages. The line number of the encountered <span class="var">ERROR</span> message will be changing as you successively fix them, until no more errors are reported.<br><br>
    Let’s analyze an example of a bug-ridden module script, <span class="var">buggy.lua</span>, in which we will identify each problem and fix it:
    <div class="code">
      <button class="btn" onclick="copyCode(this)"><span class="tooltip">Copy to clipboard</span><img src="clipboard.png"></button>
      local buggy<br><br>
      local buggyInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart()<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterIndex = getTombIndex(3)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 60<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeOut = true<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = 80<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeEnd = part.sizeStart * 8<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart = createColor(0, 255, 255)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd = createColor(255, 0, 255)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.z = 40<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.y = -60<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.accel.y = 2<br><br>
      buggy = createGroup(buggyInit, nil)
    </div>
    This is the first <span class="var">ERROR</span> reported, if we try to run this script with no alterations:
    <div class="code" style="color: red">
      ERROR: levelscripts\tut1.lua:1: modulescripts\buggy.lua:3: unexpected symbol near ')'<br>
      stack traceback:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;levelscripts\tut1.lua:1: in main chunk
    </div>
    We go to the 3rd line in <span class="var">buggy.lua</span>, as indicated by the message.
    <div class="code">
      local buggyInit()
    </div>
    We are missing something here. What is it? Well, we’re defining a function, <span class="var">buggyInit()</span>, but we have forgotten about the crucial <span class="var">function</span> keyword. The message: <span class="var">unexpected symbol near ')'</span> perhaps does not tell us this upfront. But whenever we have an ambiguous message, we should take a look at the faulty line and make an educated guess about what is wrong with it. Anyway, we fix this specific issue by adding the necessary keyword:
    <div class="code">
      local function buggyInit()
    </div>
    We run the level again and see the next <span class="var">ERROR</span> message show up:
    <div class="code" style="color: red">
      ERROR: levelscripts\tut1.lua:1: modulescripts\buggy.lua:24: 'end' expected (to close 'function' at line 3) near &lt;eof&gt;<br>
      stack traceback:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;levelscripts\tut1.lua:1: in main chunk
    </div>
    We now see the message points to line 24 of the script:
    <div class="code">
      buggy = createGroup(buggyInit, nil)
    </div>
    Is there something wrong there? It doesn’t seem like it, looks rather correct at first glance. But let’s re-read the message: <span class="var">'end' expected (to close 'function' at line 3) near &lt;eof&gt;</span>. Did you catch it? The plugin is telling us that the <span class="var">end</span> keyword, to close the function beginning at line 3, was not found. So, we add that missing <span class="var">end</span> keyword:
    <div class="code">
      local function buggyInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart()<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterIndex = getTombIndex(3)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 60<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeOut = true<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = 80<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeEnd = part.sizeStart * 8<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart = createColor(0, 255, 255)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd = createColor(255, 0, 255)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.z = 40<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.y = -60<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.accel.y = 2<br>
      end
    </div>
    After running the script once more, we see yet another message:
    <div class="code" style="color: red">
      ERROR: modulescripts\buggy.lua:4: ParticleGroup expected<br>
      stack traceback:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[C]: in global 'createSpritePart'<br>
      &nbsp;&nbsp;&nbsp;&nbsp;modulescripts\buggy.lua:4: in function &lt;modulescripts\buggy.lua:3&gt;
    </div>
    This message points to something on line 4:
    <div class="code">
      local part = createSpritePart()
    </div>
    I think this one is very easy to identify. We are not passing any argument to <span class="var">createSpritePart()</span>! The message even tells us: <span class="var">ParticleGroup expected</span>. We have called the group variable <span class="var">buggy</span>, so we pass it to the function:
    <div class="code">
      local part = createSpritePart(buggy)
    </div>
    We repeat the drill of re-running the script, receiving yet another message:
    <div class="code" style="color: red">
      ERROR: modulescripts\buggy.lua:8: number expected<br>
      stack traceback:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;[C]: in metamethod 'newindex'<br>
      &nbsp;&nbsp;&nbsp;&nbsp;modulescripts\buggy.lua:8: in function &lt;modulescripts\buggy.lua:3&gt;
    </div>
    We go to line 8, where we see:
    <div class="code">
      part.fadeOut = true
    </div>
    Reading the message, it tells us: <span class="var">number expected</span>. To the field <span class="var">part.fadeOut</span> we assigned the boolean value <span class="var">true</span>. A boolean is not a number. So, I think the solution really speaks for itself:
    <div class="code">
      part.fadeOut = 30
    </div>
    We run the level one last time and… no more errors! We have successfully fixed every issue lurking in the <span class="var">buggy.lua</span> script, hurrah!<br>
    <img class="fig" src="ch2/buggy_fixed.gif"><br>
    <h4>Fixing missing file errors</h4>
    You will get these <span class="var">ERROR</span> messages if the plugin is unable to locate a level script file with the name given by the ExtraNG string in <span class="var">CUST_LEVEL_SCRIPTS</span>, or if the plugin cannot find a module matching the string given to <span class="var">require()</span> inside a level script. The plugin cannot do anything about these missing script files, other than to throw an <span class="var">ERROR</span> message and abort importing them.<br>
    <img class="fig" src="ch2/levelscript_error.png">
    <img class="fig" src="ch2/module_error.png"><br>
    There are two probable reasons for missing Lua scripts. The first is that the file was misplaced in some other directory (e.g. you accidentally added a level script to the <span class="var">modulescripts</span> folder, or vice-versa). The other is that you typed the name of the level script or module script incorrectly (e.g. with a typo). As a reminder, level script file names are always added <u>without</u> the <span class="var">.lua</span> extension to the <strong>ExtraNG strings</strong> section in <span class="var">english.txt</span>. The module script names are typed in string quotes in <span class="var">require()</span> function, again without the <span class="var">.lua</span> extension. Adding the extension is not only unnecessary, it’s invalid!<br><br>
    <hr>
    <a name="id6"><h3>Using the print() function for debugging</h3></a>
    The built-in function <span class="var">print()</span> is a really useful debugging function. It is able to print certain Lua values (mainly strings, numbers and booleans) as a <span class="var">DEBUG</span> message in the log. This functionality allows for two things:
    <ol>
      <li>Checking if the <span class="var">print()</span> instruction and the code surrounding it is reachable (i.e. whether the flow logic can progress to the code block containing <span class="var">print()</span>, e.g. under some if-condition)</li>
      <li>Checking if the printed value of a variable, data field or some expression is indeed the one we expected to get (mostly applies to numeric/boolean values).</li>
    </ol><br>
    <h4>Checking if a block of code is reachable</h4>
    The first aspect of <span class="var">print()</span> allows us to verify if the code in question is even executed in the first place, or if it is somehow skipped. For example, in the following code snippet:
    <div class="code">

      local part = createSpritePart(dustgroup)<br>
      print("created dustgroup particle!")
    </div>
    We are verifying the plugin is actually creating particles of the <span class="var">dustgroup</span> particle group. Seeing <span class="var">DEBUG</span> messages with the contents <span class="var">created dustgroup particle!</span> confirms that such particles are indeed created:
    <img class="fig" src="ch2/debug0.png"><br>
    Naturally, if the code section hosting the <span class="var">print()</span> is entered on each tick or even several times per tick (e.g. in a for loop), we will see a long litany of these messages being spammed in the logger.<br><br>
    We can also use this technique to evaluate whether if conditions are performing as we expect them to:
    <div class="code">
      part.spriteIndex = 11<br>
      part.lifeSpan = randomInt(50, 100)<br>
      if part.lifeSpan % 2 == 0 then<br>
      &nbsp;&nbsp;&nbsp;&nbsp;print("inside if condition block")<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 14<br>
      end
    </div>
    we first assign <span class="var">11</span> to <span class="var">part.spriteIndex</span>. Then we generate a randomized life span for the particle. Afterwards, in an if condition, we check if the <span class="var">part.lifeSpan</span> value is divisible by 2 via the <span class="var">%</span> modulo operator. If true, we re-assign <span class="var">14</span> to the <span class="var">part.spriteIndex</span>. What if we want a confirmation that the code inside the if-block can be reached? I mean, it seems rather likely that some of the particles will end up with <span class="var">spriteIndex = 14</span>, but how can we verify this directly in the code, instead of closely examining the particles in game? Easy, somewhere inside the if-block, we add a <span class="var">print()</span> function call with some arbitrary string message (e.g. <span class="var">"inside if condition block"</span>). For every time the if-block was entered, we should see a <span class="var">DEBUG</span> message pop up in the logger, printing our string:
    <img class="fig" src="ch2/debug1.png"><br>
    Perhaps we could also tell that some particles indeed use sprite 14 instead of 11, which would serve as visual confirmation that the above code snippet works. Unfortunately, not in all cases will there be obvious signs if the code was executed or not. For example, say that instead of assigning a different sprite, we played a certain sound effect. The function for playing specified sound effects, <span class="var">soundEffect()</span>, will be explained eventually in these tutorials, but for now you only have to know that in the following example, it will play the sound effect with ID 285, <strong>OBJ_GEM_SMASH</strong> (the flare sound effect in TR4):
    <div class="code">
      if part.lifeSpan % 2 == 0 then<br>
      &nbsp;&nbsp;&nbsp;&nbsp;soundEffect(285, part.pos, 0) <span class="com">-- play sound effect 285 at particle position</span><br>
      end
    </div>
    Now, imagine in this hypothetical situation, that you play the game, but you do not hear the sound effect at all, despite clearly seeing particles. What’s even weirder, we see no error messages in the logger that would indicate some obvious problem with our code. What gives? Well, there are two possibilities: either the code block containing the <span class="var">soundEffect()</span> call is never entered (indicating an issue with the code logic), or there is something not right about the sound effect (an issue outside the Lua script, perhaps due to missing sound samples in the outputted level). To outrule the lack of sound effect being a problem with the Lua script, we can add a <span class="var">print()</span> call immediately after the <span class="var">soundEffect()</span> function call, to confirm that the script does in fact enter the if-block (if the <span class="var">print()</span> is executed, so was the <span class="var">soundEffect()</span> right before it):
    <div class="code">
      if part.lifeSpan % 2 == 0 then<br>
      &nbsp;&nbsp;&nbsp;&nbsp;soundEffect(285, part.pos, 0) <span class="com">-- play sound effect 285 (OBJ_GEM_SMASH) at part position</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;print("after soundEffect() call") <span class="com">-- confirm that the script executes this code block</span><br>
      end
    </div>
    If the logger shows a <span class="var">DEBUG</span> message with the message text: <span class="var">after soundEffect() call</span>, we can confidently determine that the script is working as expected, thus the sound effect issue must have a different root cause (maybe it is a missing sound sample in the outputted level, after all). Disambiguating and narrowing down the source of issues in this way is quite helpful and saves you precious time spent looking in the wrong places.<br><br>
    <h4>Checking the value of a variable / expression / data field</h4>
    While sending string messages to console allows us to test if the code is reachable, or test correct execution order, sometimes we want to further verify if the executed code gave us the exact result we were anticipating. This is a secondary application of the <span class="var">print()</span> function. Instead of providing (only) a string argument, we specify a variable, data field or expression that will evaluate to a number or boolean <span class="var">true</span> / <span class="var">false</span> value.<br><br>
    As an example, we can use this to check if the mathematical expression gives us the value we are expecting to get:
    <div class="code">
     local angle = degToRad(30)<br>
     local num = sin(angle)<br>
     print("the value of 'num' is", num)
    </div>
    We are assigning to <span class="var">local angle</span> the value of <span class="var">degToRad(30)</span>, which gives us the angle value 30°, but expressed in <a href="Chapter1.html#radians">radians</a>, the expected input for <span class="var">sin()</span>. Then, for <span class="var">local num</span>, we assign the result of <span class="var">sin(angle)</span>. Interestingly, the <span class="var">print()</span> function can take several arguments. If you pass more than one value, it will print out all of them in a row, separated by horizontal tabs. Here, we have decided to add a string prefix that will apear in front of the number value. Before the actual <span class="var">num</span> value, we have passed a string:<br><br><span class="var">&nbsp;&nbsp;&nbsp;&nbsp;"the&nbsp;value&nbsp;of&nbsp;'num'&nbsp;is"</span><br><br>
    In Lua, it is possible to use a different type of quote character within a string than the one used for marking the string. Since we used <span class="var">""</span> for the outer quotes, we are able to put <span class="var">'num'</span> inside of the string and have it appear as part of the message.<br><br>
    According to mathematics, the value of sine for 30 degrees (&pi;/6 radians) should be equal to ½ (0.5). If the <span class="var">sin()</span> function works as expected, we should receive the following message in the logger:
    <img class="fig" src="ch2/debug2.png"><br>
    We can use such string and number pairings in <span class="var">print()</span> to add annotations to <span class="var">DEBUG</span> messages, explaining what the printed number or boolean represents (quite helpful when printing several number values, to know which is which).<br><br>
    Another situation where we can print out numeric values is to learn what value a certain data field is currently holding, or checking whether it’s holding the value we are expecting of it. This may be a silly example, but let’s say we want to know the default value of some unassigned particle field in the init function, before we make the assignment:
    <div class="code">
      local part = createSpritePart(group)<br><br>
      print("part.emitterIndex is", part.emitterIndex)<br>
      part.emitterIndex = getTombIndex(25)
    </div>
    From <a href="Chapter1_5.html#emitters">what we know</a> of the <span class="var">part.emitterIndex</span> field, we are expecting it to hold the value <span class="var">-1</span>, before it gets assigned a valid Tomb4 item index. We should see the following output:
    <img class="fig" src="ch2/debug3.png"><br>
    A small limitation of <span class="var">print()</span> is that you cannot directly print out the contents of structured value types, like tables or plugin data:
    <div class="code">
      local table = {1, 2, 3}<br>
      print("table is ", table)
    </div>
    In this situation, <span class="var">print()</span> will give the memory address of the table or plugin data object, which is not particularly useful for our purposes:
    <img class="fig" src="ch2/debug_table.png"><br>
    Fortunately, you can list any number of values in one print call. Here is an example for printing RGB values of <span class="var">part.colStart</span>:
    <div class="code">
      part.colStart.r = randomInt(60, 90)<br>
      part.colStart.g = randomInt(120, 160)<br>
      part.colStart.b = randomInt(200, 250)<br><br>
      print("part.colStart is (", part.colStart.r, part.colStart.g, part.colStart.b, ")")
    </div>
    The formatting on such an output is perhaps not ideal, but nicely formatted outputs are not really what <span class="var">print()</span> is designed for. It’s merely a tool for obtaining direct feedback from the code we have written and interrogating its execution in real time.<br>
    <img class="fig" src="ch2/debug4.png"><br>
    Once we are done testing the code we were working on, we may comment out or remove all the <span class="var">print()</span> calls (in fact, it is recommended for best performance).<br><br>
    <hr>
    Even though this chapter was a slight change of pace and may have slowed your momentum due to its technicality, it was a very necessary pitstop to make before the road ahead. Using the logger features, knowing how to manage script errors and debugging with the <span class="var">print()</span> function is invaluable for more advanced particle scripting. The chapters ahead will frequently bring up checking for warning or error messages in the console and fixing them when our code misbehaves. Hopefully, the time invested into getting through this chapter was time well spent and you will not be confused when you encounter references to the logger, <span class="var">WARN</span> / <span class="var">ERROR</span> messages and <span class="var">print()</span> from this point onwards.<br><br>
    See you in <strong>Chapter 3</strong> – update functions!<br><br>
    <table width=100%>
      <tr>
      <td><a href="Chapter1_5.html"><strong>&lt;&lt;&lt;&nbsp;PREV</strong></a></td>
      <td style="text-align: right"><a href="Chapter3.html" ><strong>NEXT&nbsp;&gt;&gt;&gt;</strong></a></td>
      </tr>
    </table>
  </body>
</html>
