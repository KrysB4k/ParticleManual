<!DOCTYPE html>
  <html>
  <head>
    <title>1.5 – Init functions, continued</title>
  </head>
  <body text=#000000 bgcolor=#FFFFFF link=#0000FF alink=#0000FF vlink=#0000FF>
    <link rel="stylesheet" href="styles.css"/>
    <script src="copycode.js"></script>
    <h1>Init functions, continued</h1>
    <table width=100%>
      <tr>
      <td><a href="Chapter1.html"><strong>&lt;&lt;&lt;&nbsp;PREV</strong></a></td>
      <td style="text-align: right"><a href="Chapter2.html" ><strong>NEXT&nbsp;&gt;&gt;&gt;</strong></a></td>
      </tr>
    </table>
    <br>
    In the previous half of Chapter 1, we have talked about init functions and various particle properties to go with them, which already gave us plenty of options for simple particle effects.<br><br>
    In this second half of the chapter, we will learn how to change the spawn rates of particles, then go over some remaining sprite particle fields we have not covered yet, such as the emitter index and emitter node, acceleration vector, size ratio factor and color fading time. In particular, we will examine how you can use the <span class="var">emitterIndex</span> and <span class="var">emitterNode</span> fields to mimic the AddEffect feature known from TRNG, but with fully customizable effects, created by you.<br><br>
    The end of this chapter hosts an optional bonus section that showcases some neat tricks made possible thanks to bit of math, to generate various spatial arrangements and intricate spawning patterns for particles. This last section will mosty likely be enjoyed by those readers who have a knack for mathematics, so if you are not very interested in topics of 2D and 3D geometry or parametric equations, feel free to skip it and head directly to the next chapter.
    <hr>
    <h2>Sections</h2>
    <strong>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id1">1. Changing particle spawn rates</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id2">2. Particles emitted from objects</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id3">3. Particle emitter nodes</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id4">4. Particle acceleration</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id5">5. Particle size ratio factor</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id6">6. Particle color fading time</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id7">7. Bonus: Geometric spawning formations</a>
    </strong><br>
    <hr>
    <a name="id1"><h3>Changing particle spawn rates</h3></a>
    <i>Note: this section is a tad more technical and may take some resilience to get through it. However, I strongly believe what you learn thanks to it makes this effort worth it, please don’t skip this one!</i><br><br>
    Though this is also a subjective matter, I think the way our dust particles spawn at the moment is a bit too “concentrated”. Perhaps the particles should be spread out more, to cover a larger area (you may disagree with me, like I said it’s subjective). Regardless if you agree or not, I will tell you about the ways to modify the particle density and spawn rate, for when it becomes necessary.<br><br>
    We can do one of the following, or both:
    <ul>
      <li>spread out the dimensions of the volume in which particles can spawn (by increasing the random range of the position randomizing variables <span class="var">dx</span>, <span class="var">dy</span>, <span class="var">dz</span> in our script);
      <li>make the particles spawn less frequently (i.e. not on every frame).
    </ul><br>
    <h4>Spreading out the spawn dimensions</h4>
    The first point should seem rather straightforward, we can do that by increasing the range of the <span class="var"> dx, dy, dz</span> variables for generating the random numbers we add to the position vector. To make the particles cover a larger area, we simply change the min-max range in the <span class="var">randomFloat()</span> calls. Let’s try increasing it to (-1024, 1024) for <span class="var">dx</span> and <span class="var">dz</span>, making the effective volume a box of dimensions 2048 x 1024 x 2048.
    <div class="code">
      local dx = randomFloat(-1024, 1024) <span class="com">-- 2048 total</span><br>
      local dy = randomFloat(-512, 512) <span class="com">-- 1024 total</span><br>
      local dz = randomFloat(-1024, 1024) <span class="com">-- 2048 total</span>
    </div>
    Easy-peasy. Now, the same amount of particles spawns as before (1 per frame), but the volume in which they spawn became bigger, precisely 4 times. Hence, there is a smaller average density of particles per unit of space.<br><br>
    Spawning particles with a different frequency than 1 per frame is not so straightforward, though – how do we make particles spawn less often? After all, we recognize the init function is being called by the plugin once per frame.<br>
    Indeed, it’s true that the init function will be automatically called once per frame by default (generally speaking, there is a specific particle group setting which controls whether this is the case or not). I never said it necessarily must spawn a particle on each of those frames though, now did I?<br><br>
    Recall the <strong>Lua Crash Course</strong> section on <a href="LuaManual.html#if">if conditions</a>. You will greatly benefit from refreshing this knowledge, if you are not up to speed with that aspect of Lua.<br><br>
    <h4>Probability-based spawn rates</h4>
    Random number functions can be used for simulating probabilistic outcomes, like rolling dice or flipping coins (or generating some other odds). Specifically, I’m referring to <span class="var">randomInt()</span> for this purpose. What would happen if we spawned a new particle, but <u>only</u> under the condition that the result of <span class="var">randomInt(1,&nbsp;6)</span> was equal to 3, for example? We would get a 1 in 6 chance of the particle spawning a given frame, the same as with rolling out a 3 on a die (“die” being the singular form of “dice”). Or perhaps <span class="var">randomInt(1,&nbsp;2)</span> being equal to 1, as with a coin flip (“heads” or “tails”) that resulted in “heads”. To make room for this element of chance, we must make some small alterations to the code around spawning the particle.<br><br>
    The main idea is to have a variable, to which we assign a random integer in some particular range, for example 1 through 6. We’ll give this variable the descriptive name <span class="var">dice</span>. To this variable we then assign the result of <span class="var">randomInt(1, 6)</span>, which will be our random integer between 1 and 6, different on each frame.
    <div class="code">
      local dice = randomInt(1, 6)
    </div>
    I will proceed to describe how we can construct our if conditional statement around the <span class="var">dice</span> variable. There are in fact two ways of reasoning about it, both leading to the same outcome.
    First of all, we should establish the condition – when should our particle spawn? Whenever we “roll out” a 1 with <span class="var">dice</span>, for instance. It wouldn’t matter if we chose 2, 3, 4, 5 or 6 instead, since there should be an equal probability that we get any of these six outcomes, if the die is fair.
    As for the two ways of writing the if condition, we can perceive it from two complimentary perspectives:
    <ul>
      <li>we want to spawn the particle only if the value of <span class="var">dice</span> is 1 (<span class="var">dice == 1</span>)
      <li>we want to return from (skip further execution of) the function if the value of <span class="var">dice</span> is greater than 1 (<span class="var">dice > 1</span>).
    </ul>
    I hope it makes sense to you how both of these viewpoints effectively lead to the same outcome and are equivalent to each other. The ultimate result is that the particle is spawned only on those frames where the <span class="var">dice</span> variable had the value <span class="var">1</span>.<br><br>
    Let’s analyze setting up the if condition by following the sentiment of the first perspective. We need the <span class="var">if</span> keyword to begin the conditional statement. Next we describe the condition: <span class="var">dice == 1</span>. At the end of the line, we put <span class="var">then</span>:
    <div class="code">
      local function dustInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local dice = randomInt(1, 6)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if dice == 1 then <span class="com">-- if we rolled out a 1</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(dustgroup) <span class="com">-- create a sprite particle of the "dust" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 4 <span class="com">-- 30 frames * 4 = 4 seconds</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = 150<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- remaining part init code --</span><br><br>
      end
    </div><br>
    What follows after the <span class="var">then</span> keyword becomes a code block belonging to the if statement, up until first encountered <span class="var">end</span> keyword is reached. We would now need to place everything related to spawning the particle (creating the new particle instance and initializing the fields) inside the code block of the if condition. Now, there is a very lazy way to do this, which involves simply placing an extra <span class="var">end</span> keyword before the <span class="var">end</span> that terminates the <span class="var">dustInit()</span> function. Remember, Lua does not care about whitespaces (unlike the Python programming language, for instance), it only cares that the code-block is between the <span class="var">then</span> and <span class="var">end</span> keywords, does not matter how:
    <div class="code">
      local function dustInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local dice = randomInt(1, 6)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if dice == 1 then <span class="com">-- if we rolled out a 1</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(dustgroup) <span class="com">-- create a sprite particle of the "dust" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 4 <span class="com">-- 30 frames * 4 = 4 seconds</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = 150<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- remaining part init code --</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;end <span class="com">-- end terminating if code block</span><br>
      end <span class="com">-- end terminating dustInit() function</span>
    </div><br>
    However, on top of this being lazy (something which I do not mind at all, personally), I consider it quite ugly and unintelligble (which I do mind, actually). On the other hand, making this code more structured and comprehensible would require adding a lot of whitespace indentation to several lines, which I don’t want to do, either. Which will prevail here, tidyness or laziness?<br><br>
    <a name="newfunc"></a>Let’s scrap this idea. I have a smarter solution that will leave the <span class="var">dustInit()</span> function intact (needing no changes), but which still allows us to change how frequently the particles get spawned by it. Let’s define a completely new function <u>below</u> <span class="var">dustInit()</span>. We can name it something like <span class="var">dustInit_chance()</span> (or whatever tickles your fancy):
    <div class="code">
      local function dustInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local dice = randomInt(1, 6)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if dice == 1 then <span class="com">-- if we rolled out a 1</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(dustgrpup) <span class="com">-- create a sprite particle of the "dust" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 4 <span class="com">-- 30 frames * 4 = 4 seconds</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = 150<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- remaining part init code --</span><br><br>
      end<br><br>
      local function dustInit_chance() <span class="com">-- our new function</span><br>
      end
    </div>
    We will move the <span class="var">dice</span> variable and if condition from <span class="var">dustInit()</span> into this new function, then remove it from the old function, reverting it to its original state:
    <div class="code">
      local function dustInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(dustgroup) <span class="com">-- create a sprite particle of the "dust" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 4 <span class="com">-- 30 frames * 4 = 4 seconds</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = 150<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- remaining part init code --</span><br><br>
      end<br><br>
      local function dustInit_chance()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local dice = randomInt(1, 6)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if dice == 1 then <span class="com">-- if we rolled out a 1</span><br>
      end
    </div>
    In the if condition block that’s now inside <span class="var">dustInit_chance()</span>, we call our original <span class="var">dustInit()</span> function from above. Then we terminate the if condition block with the <span class="var">end</span> keyword:
    <div class="code">
      local function dustInit_chance()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local dice = randomInt(1, 6)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if dice == 1 then <span class="com">-- if we rolled out a 1</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dustInit() <span class="com">-- call our original init function</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;end<br>
      end
    </div>
    One last thing needed to make this work is to replace the <span class="var">dustInit</span> function in <span class="var">createGroup(dustInit, nil)</span> with our new <span class="var">dustInit_chance</span> function.
    <div class="code">
      dustgroup = createGroup(dustInit_chance, nil) <span class="com">-- swapping out original dustInit function with dustInit_chance</span>
    </div>
    Now all that’s left is to try it out in-game.<br>
    <img class="fig" src="ch1_5/ch15_spawnrate.gif"><br>
    The spawn rate of the particles has definitely gone down. A bit too much, perhaps. Back in our <span class="var">dustInit_chance()</span>, we can decrease the <span class="var">randomInt()</span> range on <span class="var">dice</span> from (1, 6) to (1, 2). This should now result in a 50/50 likelyhood of spawning the particle. If we really want to, we can also change the name of the variable to <span class="var">coin</span> to reflect that.
    <div class="code">
      local function dustInit_chance()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local coin = randomInt(1, 2)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if coin == 1 then <span class="com">-- if we got "heads" on the coin</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dustInit() <span class="com">-- call our original init function</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;end<br>
      end
    </div>
    Nice, that’s closer to what I had in mind.<br><br>
    The method of checking a randomly generated integer is based on probability. It results in an <u>average</u> spawn rate of about 1 particle per 6 frames for the “dice” probability (or 1 particle in 2 frames for the “coin” probability). This is only true when averaged out over a certain period of time, though. In one exact moment, it’s not possible to determine if we get a particle to spawn or not. There’s a very small, but entirely possible chance to get a “streak” of 8 frames with spawned particles in a row, or a “streak” of no particles for 10 consecutive frames, even if the probability would suggests otherwise. Such sequences, though rare and tend to average out in the long run, are unavoidable with statistical probabilities, where events occur only with a chance.<br><br>
    <a name="interval"><h4>Interval-based spawn rates</h4></a>
    What if we do not want such probabilistic outcomes, based on certain odds, but predictable ones? Is there way to make an event occur with a consistent, precise interval, e.g. where we are guaranteed to get <u>exactly</u> 1 particle spawned every 15 frames? Yes, this can also be accomplished.<br><br>
    One way to do it is by using an API function called <span class="var">getGameTick()</span>. This function does not accept any arguments and returns the number of game ticks (frames) that have elapsed in-game since starting the current level (reminder that the TRLE engine runs at a constant 30 fps, so 1 second passes every increment of 30 game ticks). The tick counter doesn’t go up while in the inventory or pause screens. It resets to 0 when a new level is loaded and starts counting up again. It’s also saved in save games and reverted back to the saved value after reloading. Effectively, it behaves like a “clock” that measures how much game ticks passed since starting the current level. Whenever we want something in an effect to depend on the passage of time, we can reliably use the <span class="var">getGameTick()</span> function. Right now, we can use it for spawning particles in a rigid interval.<br><br>
    The <span class="var">getGameTick()</span> will return the elapsed number of ticks since the level began. But that alone will not get us where we want. We still have to do something with that value, which will result in a particle spawning once every certain number of frames. Let’s a look at the table of Lua <a href="LuaManual.html#arith">arithmetic operators</a> for a moment. We are looking for an operator that can return the remainder of dividing one number by another. The modulo operator <span class="var">%</span> seems to fit the description, right?<br><br>
    The idea here is rather simple, we perform a modulo operation on the value returned by <span class="var">getGameTick()</span>, where the dividend (the number to the right of the modulo operator) is the desired spawn interval, in frames.<br><br>
    We will adapt our existing <span class="var">dustInit_chance()</span> function, making certain changes to it. We may rename our <span class="var">dice</span> / <span class="var">coin</span> variable to <span class="var">tick</span>. Let’s go for a spawn interval of 1 particle per 15 frames, or one every half-second (since there are 30 frames to a second in this engine). We make the following changes:
    <div class="code">
      local function dustInit_chance()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- take the tick counter value and get remainder from division by 15 (our interval)</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local tick = getGameTick() % 15<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if tick == 0 then <span class="com">-- on every 15th frame</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dustInit() <span class="com">-- call our original init function</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;end<br>
      end
    </div>
    What the modulo operation is doing is it will return the remainder (the “leftover”) of dividing the elapsed game tick count (returned from <span class="var">getGameTick()</span>) by 15. This remainder is an integer between 0 and 14 (inclusive) and it gets assigned to <span class="var">tick</span>. When we check if <span class="var">tick</span> is equal to a specific value in the range of the remainder, such as 0, this condition will be true exactly once every 15 ticks (as the game tick count keeps increasing).<br><br>
    After running the level, we see that the particle is indeed spawned precisely every 15 frames, or once per half-second. You can easily get any other interval, all you need to do is change the integer to the right of the modulo operator.<br><br>
    <h4>The interval() function</h4>
    There is an even easier way to spawn a particle on every <span class="var">Nth</span> frame. It is an API function named <span class="var">interval()</span>, the purpose of which is precisely to do some action once every given number of ticks. The function takes a mandatory first argument, the number of ticks in the interval. This has to be a positive integer (which makes perfect sense, an interval must be at least 1 frame long). The function returs a boolean value, <span class="var">true</span> if the current game tick is divisible by the first integer given to <span class="var">interval()</span> (e.g. if we use 15, it will be true on the 0 tick (immediately after launching the level) and then every 15th tick). In any other case, the returned boolean is <span class="var">false</span>. With <span class="var">interval()</span>, we can convert the code of <span class="var">dustInit_chance()</span> to the following:
    <div class="code">
      local function dustInit_chance()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if interval(15) then <span class="com">-- on every 15th frame</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dustInit() <span class="com">-- call our original init function</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;end<br>
      end
    </div>
    And the result will be identical to the previous version with <span class="var">getGameTick()</span> and the modulo operator, just sparing us a couple steps.<br><br>
    The <span class="var">interval()</span> function can also take an optional second argument, the delay. This is also an integer, but in the range between 0 and the first interval argument (so the allowed range depends on what the first argument was). This second argument serves to offset the tick timer, by the given number of ticks. Effectively, this allows to delay the interval condition by the specified number of frames. Going with our example again, if we use <span class="var">interval(15, 1)</span>, the interval function will return <span class="var">true</span> 1 tick later than <span class="var">interval(15)</span> or the equivalent <span class="var">interval(15, 0)</span>. Likewise, <span class="var">interval(15, 5)</span> returns <span class="var">true</span> 5 ticks later, <span class="var">interval(15, 10)</span> returns <span class="var">true</span> 10 ticks later, and so on. This can be useful to set up a sequence, where in a given interval, you trigger something on the 1st, 5th, 9th and 14th frame, in sequence (and with an optional <span class="var">else</span> statement, you can do something default on all other, unspecified frames):
    <div class="code">
      if interval(15, 1) then <span class="com">-- on 1st frame</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- do 1st thing</span><br>
      elseif interval(15, 5) then <span class="com">-- on 5th frame</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- do 2nd thing</span><br>
      elseif interval(15, 9) then <span class="com">-- on 9th frame</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- do 3rd thing</span><br>
      elseif interval(15, 14) then <span class="com">-- on 14th frame</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- do 4th thing</span><br>
      else <span class="com">-- do default thing on all other frames in interval (optional)</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- optional default thing</span><br>
      end
    </div>
    Such a sequence repeats itself every 15 frames, behaving like a TRNG <span class="var">Organizer</span> with <span class="var">FO_TICK_TIME + FO_LOOP</span>.<br><br>
    <h4>Spawning multiple particles per frame</h4>
    To make our life easier for limiting particle spawn rate, we have written a “master” function, <span class="var">dustInit_chance()</span>, which decides when to spawn a dust particle and calls the original <span class="var">dustInit()</span> function to spawn one. Meanwhile, the only job of <span class="var">dustInit()</span> is to spawn and initialize a single new particle of the dust group. Make note of the fact that the init function given to a particle group definition does not necessarily have to be the very function that actually spawns the particles (in this case, <span class="var">dustInit()</span>), but can be a completely different one (e.g. <span class="var">dustInit_chance()</span>), which provides more specific control over when and how a particle is spawned – we will explore this topic and its implications even further at some point.<br><br>
    This method of modularizing code into functions and distributing one job per function is a stellar approach, indicative of well-written code. This is because you can easily tell what each function is responsible for, when you know it only has a single job (also naming your functions appropriately with their performed tasks massively helps with this). On the contrary, if we squeeze everything together into one big function, it obscures the whole picture and you would have to remember this “monster” function does many jobs, some of which are not really related to the name of the function.<br><br>
    Of course, we had a rather trivial example here. In programming practice, this one-job-only rule isn’t something that can always be enforced reliably, there will be inevitable edge cases and debacles of what constitutes a “single job” for a function. As a general guideline, though, you should prefer to write each function with (ideally) one task in mind. If the task consists of several smaller tasks, you isolate those sub-step tasks into smaller functions and call them each from the bigger function (within reason, that is). This results in cleaner and more elegant code. As a reminder, functions exist specifically to reduce repetition and help to code things more efficiently.<br><br>
    <a name="multispawn"></a>Anyway, once we have realized that the <span class="var">dustInit()</span> function is an executable unit that spawns a single dust particle on demand, it’s trivial to modify <span class="var">dustInit_chance()</span> again, this time to spawn several particles per frame. You simply call <span class="var">dustInit()</span> however many times is required inside the master <span class="var">dustInit_chance()</span>. Should you need to spawn particles in the tens, hundreds, or in some randomized amount, preferably use <a href="LuaManual.html#loops">for loops</a>. For just 3 particles, repeating the function call three times in a row is hardly the worst thing in the world.
    <div class="code">
      local function dustInit_chance()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- spawn 3 dust particles per frame</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;dustInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;dustInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;dustInit()<br>
      end
    </div>
    And that’s all there is to it. We can see the clear benefit from modularizing code into functions – logical units that each perform a single task. This way, you may use that one function several times in different places, instead of copy-pasting and adapting the same code snippet over and over. This becomes even more apparent when the particles must be spawned in bursts, batches, in a particular time pattern or under highly specific conditions.<br><br>
    Okay, time for a moment of honesty. The original spawn rate of 1 particle per frame did not bother me at all, nor do I consider it excessive. This whole section was just my cunning, evil trickery to explain how you can modify the particle spawn rates! <i><strong style="color: red">Muahahahaha!</strong></i><br><br>
    Nonetheless, I hope that after working through all these examples, you know how you can decrease or increase the frequency of not only particle spawning, but any kind of event. Both the probability-based and interval-based approach will be making an appearance again in later chapters, but we will really be needing it then (really, I promise)!<br><br>
    You can keep using the <span class="var">dustInit_chance()</span> function if you indeed want a modified spawn rate of the dust particles, otherwise we can just restore the good old <span class="var">dustInit</span> in the call to <span class="var">createGroup()</span>.
    <div class="code">
      dustgroup = createGroup(dustInit, nil) <span class="com">-- restoring the original dustInit function</span>
    </div>
    <hr>
    <a name="id2"><h3>Particles emitted from objects</h3></a>
    When we were giving our particles <a href="Chapter1.html#id6">a position</a> back in the first half of Chapter 1, we grabbed the absolute coordinates of Lara from some spot in the level. You might agree this is a rather tedious, mundane process. Specifying position this way is not very flexible, either. What if we want to change the position of the effect?
    Do we keep grabbing new coordinates with Lara in DOZY mode? Or what if we want to spawn our dust particles in a second spot, do we need to replicate the <span class="var">dustInit()</span> function, but with changed XYZ coordinates?<br><br>
    No, this would be a ridiculously tedious thing to do whenever we want to place the same effect somewhere else in the level.<br><br>
    If you are familiar with how FLEP smoke emitters work, you are aware that they are spawned from placed SMOKE_EMITTER_WHITE and SMOKE_EMITTER_BLACK nullmesh objects, with the particle properties depending on the settings of a given OCB number in the patch. Anyway, this allowed to spawn the particles depending on where the emitter nullmesh was placed, and the nullmesh emitted particles after getting triggered. This emitter system seems more convenient, since it allows you to easily adjust the exact location the particles will appear in and even place the same effect in several spots. It would be awesome if we could have that level of convenience available with our dust particles, wouldn’t it?<br><br>
    It’s really obvious where I’m going with this, so let’s cut to the chase.<br><br>
    <a name="emitters"><h4>Relative spawn positions with emitterIndex</h4></a>
    The particles from this plugin have two specific properties / fields that deal with this exact sort of thing, the <span class="var">part.emitterIndex</span> and the <span class="var">part.emitterNode</span>. In this section, I will focus on explaining the <span class="var">part.emitterIndex</span> field.<br><br>
    Specifying a <span class="var">part.emitterIndex</span> in the init function ties the particle’s position to an <strong>emitter item</strong>. What is this emitter item, you ask? It can be <strong><u>any</u></strong> moveable object in the level. Yes, you heard me correctly, <u>any moveable item</u> can serve as the particle emitter object. It does not have to be a nullmesh, it can also be an enemy, it can be a trap, pushblock, pickup or animating. It can even be Lara herself.<br><br>
    What kind of index does this <span class="var">emitterIndex</span> field expect, though? It is sadly not the NG script index, which was probably your first thought, but rather the internal Tomb4 item index (there are specific reasons for this, the engine-side Tomb4 indices are more general-purpose, as used by the underlying engine). However, do not fret, as the API has a function that resolves this easily. The built-in function <span class="var">getTombIndex()</span> takes the NG index for the moveable and converts it to the corresponding Tomb4 item index (if a moveable with the given NG index exists, that is, otherwise it returns the erroneous value <span class="var">-1</span> for an invalid item).<br><br>
    Differently than other fields, the uninitialized <span class="var">part.emitterIndex</span> field starts out with value <span class="var">-1</span> and not <span class="var">0</span>. This is because 0 is also a valid Tomb4 index that any item in the level could have. If <span class="var">part.emitterIndex</span> has the default <span class="var">-1</span> value, the position coordinates given to the particle are interpreted as global (absolute) coordinates in the level. On the other hand, when it is set to a valid item index, the particle’s position coordinates will become relative to the corresponding emitter item (though this is an oversimplification, the full picture of how the <span class="var">emitterIndex</span> works will be revealed later, in context of the <strong>particle tethering system</strong>).<br><br>
    To illustrate this with a specific example, if the particle has been assigned <span class="var">part.pos</span> coordinates: <span class="var">(x&nbsp;=&nbsp;-256,&nbsp;y&nbsp;=&nbsp;-768,&nbsp;z&nbsp;=&nbsp;1536)</span>, the particle will be offset by those position coordinates from the emitter item’s current position, which could be <span class="var">(x&nbsp;=&nbsp;1024,&nbsp;y&nbsp;=&nbsp;0,&nbsp;z&nbsp;=&nbsp;2048)</span>. When determining where the particle actually appears in the level map, i.e. its (<span class="var">xFinal, yFinal, zFinal</span>) coordinates, the particle position vector becomes <u>relative to the local coordinate system</u> of the item, where X offsets are to the left and right of the item, Y offsets are above and below the item, and Z offsets are to the front and back of the item. The offsets are calculated from the emitter item’s pivot point (the origin, as seen when viewing the object in e.g. WadTool). Assuming the case that the item has the default rotation after being placed in the level map, the particle attached to the emitter will receive the following (<span class="var">xFinal, yFinal, zFinal</span>) coordinates:
    <div class="code">
      xFinal = (1024 - 256) = 768 <span class="com">-- item.pos.x + part.pos.x</span><br>
      yFinal = (0 - 768) = -768 <span class="com">-- item.pos.y + part.pos.y</span><br>
      zFinal = (2048 + 1536) = 3584 <span class="com">-- item.pos.z + part.pos.z</span>
    </div>
    However, if the emitter item is in any way rotated from the default placement, this calculation is less straightforward. The <span class="var">part.pos</span> offsets of the particle are rotated with the item’s frame of reference, which effects the (<span class="var">xFinal, yFinal, zFinal</span>) coordinates. Perhaps this text explanation is hard to grasp without a visual aid. Refer to the diagram below for further clarification. The final, “true” XYZ position the particle ends up with, factors in the facing of the emitter item (X is left/right of the item, Y is up/down, Z is back/front):
    <img class="fig" src="ch1_5/emitter_pos.jpg"><br>
    There are some pitfalls to be wary of. If the <span class="var">part.emitterIndex</span> is not set to a valid Tomb index of some moveable (i.e. has the default <span class="var">-1</span> value), the particle will spawn at the global world coordinates <span class="var">(x&nbsp;=&nbsp;-256,&nbsp;y&nbsp;=&nbsp;-768,&nbsp;z&nbsp;=&nbsp;1536)</span>, which in this case would be out of level map bounds, due to the negative X coordinate. Another is the reverse situation, where we use a valid <span class="var">part.emitterIndex</span> value (making the <span class="var">part.pos</span> relative to the emitter), but (mistakingly) also give the particle global level offsets, such as <span class="var">(x&nbsp;=&nbsp;22856,&nbsp;y&nbsp;=&nbsp;-17408,&nbsp;z&nbsp;=&nbsp;35132)</span>. This will cause the particle to be offset by a huge distance away from the emitter item, making it seem like the particles aren’t spawning at all and leading to confusion or frustration. In fact, they will indeed be spawning, it will just be <u>very far away</u> from the emitter item, because these large coordinates are being added with respect to the reference frame of the emitter item!<br><br>
    When used properly, avoiding the two pitfalls described above, this emitter mechanism simplifies setting particle positions considerably, as it is enough to specify the <span class="var">part.emitterIndex</span> and the offsets from the emitter in the particle’s <span class="var">part.pos</span> vector, the particle system works out the rest. This achieves something similar to FLEP particle emitting nullmeshes. And what’s more, this works for <u>any moveable item</u> this time, not just SMOKE_EMITTERs. This means you can even have enemies or Lara spawning particles into the level, without the need for janky workarounds, like copying the item position to the emitter nullmesh with TRNG scripts. Cool!<br><br>
    Of course, there is more to the FLEP smoke emitters than simply spawning some particles in the vicinity of the nullmesh. Which particles are spawned is determined by the OCB number of the nullmesh. Also, the FLEP particles spawn only when the emitter nullmesh has been activated by a trigger and thus can be untriggered to deactivate the particles. This is perfectly possible to recreate in the particle system as well, but it’s a topic for the later chapters, where we will learn about getting a moveable item’s properties, such as the OCB number, or checking its activation status (triggered / untriggered). At the moment, it will be enough to just make one kind of particles spawn around a placed item in a continuous way.<br><br>
    <h4>Using the emitterIndex field</h4>
    I will signal only the very basics of using <span class="var">part.emitterIndex</span> for now, which is making the particles spawn at a chosen moveable’s position, regardless if it’s been triggered or not. Let’s say we have an nullmesh item placed somewhere, such as a CAMERA_TARGET (or any other moveable item, for that matter). What must we do to get the dust particles to spawn around it?<br><br>
    We must obtain its NG script index value first. In NGLE, this is the number in parentheses (e.g. <span class="var">(421)</span>) visible when highlighting a placed object. In TE, this is displayed as the ID value in square brackets when an object is selected, e.g. <span class="var">[ID = 12]</span>.
    <div style="display: flex; justify-content: center; margin-left: auto; margin-right: auto">
      <img style="margin: 20px" src="ch1_5/NGLEID.jpg">
      <img style="margin: 20px" src="ch1_5/TEID.jpg">
    </div>
    <br>
    We take this number and pass it as an argument to the <span class="var">getTombIndex()</span> function. We then assign this to the <span class="var">part.emitterIndex</span> field (note the importance of the <span class="var">getTombIndex()</span> function for converting the NGLE index).
    <div class="code">
      part.emitterIndex = getTombIndex(12) <span class="com">-- get tomb4 item index of item with NG index 12</span>
    </div>
    There is one more thing we should do, which is removing the old level coordinates written down from Diagnostics. They are no longer needed, as the particle system will now calculate the global spawn position itself, based on the specified <span class="var">part.emitterIndex</span> (remember about the huge position offset problem I brought up about just a moment ago? Let’s avoid making this glaring mistake now). We just leave the randomly generated offset values in <span class="var">dx</span>, <span class="var">dy</span> and <span class="var">dz</span> variables and assign them to the <span class="var">part.pos</span> vector directly, without global coordinates. Here is how the whole init function should look like:
    <div class="code">
      <button class="btn" onclick="copyCode(this)"><span class="tooltip">Copy to clipboard</span><img src="clipboard.png"></button>
      local function dustInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(dustgroup) <span class="com">-- create a sprite particle of the "dust" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterIndex = getTombIndex(12) <span class="com">-- get tomb4 item index of item with NG index 12</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 4 <span class="com">-- 30 frames * 4 = 4 seconds</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = randomInt(150, 300)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeEnd = part.sizeStart * 3 <span class="com">-- make dust slowly expand over time</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = randomInt(130, 150)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.g = randomInt(100, 120)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.b = randomInt(70, 85)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd = part.colStart<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- randomize position</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local dx = randomFloat(-1024, 1024)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local dy = randomFloat(-512, 512)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local dz = randomFloat(-1024, 1024)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- since we assigned an emitterIndex, we lose the need for global coordinates</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.x = dx<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.y = dy<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.z = dz<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- randomize velocity</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.x = randomFloat(-5, 5)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.y = randomFloat(-5, 5)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.z = randomFloat(-5, 5)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 0 <span class="com">-- "smoke" sprite texture</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeIn = 30 <span class="com">-- fade in for 1 second</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeOut = 30 <span class="com">-- fade out for 1 second</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- randomize rot and rotVel</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local degrees = randomInt(0, 359)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.rot = degToRad(degrees)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- generate a random float between 2 and 4, negate it half of the time</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local rotspeed = randomNegate(randomFloat(2, 4))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.rotVel = degToRad(rotspeed)<br>
      end
    </div>
    once we try it out, we should see the dust particles spawn around our chosen object. Like FLEP smoke emitters, but with way more freedom as to what we can do!<br><br><br>
    As one more little trick, I will show you how to get this particle effect to follow Lara wherever she goes. Yes, we could just write down the NG index of the LARA object from the level map and call <span class="var">getTombIndex()</span> on it, that will work perfectly fine. But specifically for our dear Lara, there’s no need to do this. The API provides the <span class="var">getLaraIndex()</span> function, which returns the Tomb4 index of Lara directly, without the need for the <span class="var">getTombIndex()</span> function. All you should do is call <span class="var">getLaraIndex()</span>, without passing any arguments:
    <div class="code">
      part.emitterIndex = getLaraIndex() <span class="com">-- get Lara's item index
    </span></div>
    We should obtain a cloud of dust particles that constantly spawn in Lara’s vicinity, wherever she is. While this dust is maybe over-the-top, this is the go-to method of attaching particle effects to Lara herself.<br>
    <img class="fig" src="ch1_5/ch15_dustlara1.gif"><br><br>
    <h4>Putting our dust effect to rest (for now)</h4>
    Although we had some hiccups at first, we have created a rather decent “dust cloud” in the end. This can be used as-is, or serve as a very solid template script for creating other modules in the future. For a moment, we are going to set this dust module aside though, switching our focus to other, interesting topics (we will return to it again briefly, in <strong>Chapter 3</strong>).<br><br>
    Some of you are perhaps somewhat disappointed, having imagined a different kind of “dust” effect going into this. One that would be more suited for the interior of an old house instead of a desert or ancient tomb. If you’re not content with the one we’ve made together in the previous sections, try this one out, free of charge!<br>
    <img class="fig" src="ch1_5/ch15_dustlara2.gif"><br>
    <div class="code">
      <button class="btn" onclick="copyCode(this)"><span class="tooltip">Copy to clipboard</span><img src="clipboard.png"></button>
      local function dustInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(dustgroup) <span class="com">-- create a sprite particle of the "dust" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterIndex = getLaraIndex()<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 4 <span class="com">-- 30 frames * 4 = 4 seconds</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = randomInt(20, 32)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeEnd = part.sizeStart<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = randomInt(60, 70)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.g = randomInt(50, 60)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.b = randomInt(30, 40)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd = part.colStart<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- randomize position</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local dx = randomFloat(-2048, 2048)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local dy = randomFloat(-1024, 1024)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local dz = randomFloat(-2048, 2048)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.x = dx<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.y = dy<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.z = dz<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- randomize velocity</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.x = randomFloat(-3, 3)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.y = randomFloat(-3, 3)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.z = randomFloat(-3, 3)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 14 <span class="com">-- "dot" sprite texture</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeIn = 30 <span class="com">-- fade in for 1 second</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeOut = 30 <span class="com">-- fade out for 1 second</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- randomize rot and rotVel</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local degrees = randomInt(0, 359)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.rot = degToRad(degrees)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- generate a random float between 2 and 4, negate it half of the time</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local rotspeed = randomNegate(randomFloat(2, 4))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.rotVel = degToRad(rotspeed)<br>
      end
    </div>
    This is a very different interpretation of a “dust effect”. It has a much smaller particle size, a slightly dimmer color, a larger spawning domain (4096 x 2048 x 4096) and uses a different sprite texture (14 instead of 0). It is focused on Lara, following her around the level, but you can couple it with other emitter moveables instead. I think it can be an acceptable “room dust” effect, would you agree? Feel free to use it in levels and tweak it to your liking!<br><br>
    Now, on with the rest of the show!
    <hr>
    <a name="id3"><h3>Particle emitter nodes</h3></a>
    The previous section dealt with spawning particles in the vicinity of specific object via <span class="var">part.emitterIndex</span>. When using this particle property, the positions received by the particles are offset from the pivot / base position of the chosen emitter moveable (where the object is currently located in the level map). Where this base position is depends on the object in question. For some objects, it even depends on the current animation e.g. for Lara it’s down at the ground level for most animations, but for swimming on the surface, its at her neck, so as you see, it is not always consistent. We could certainly make offsets from this pivot point on a case-by-case basis to have particles spawn at some different location in vicinity of the object (e.g. some specific mesh), but it is not an ideal solution in every situation. Let’s discuss why.<br><br>
    <h4>Emitting particles around meshes</h4>
    Say we would like to spawn particles near a specific mesh of a moveable, like Lara’s or an enemy’s. We could maybe try offsetting the positions “by hand” so that the particles appear near the desired mesh. However, this is not always a reliable method. To understand why, let’s picture the following situation:<br><br>
    We would like to spawn some particles near Lara’s head mesh (mesh index 14). While Lara is standing, with trial and error we obtain the offset coordinates from Lara’s pivot down on the floor, which could be something like <span class="var">XYZ(0, -720, 0)</span>. These coordinates should be correct when Lara is upright. But now imagine she goes into the crawling animations. Are the previous offsets <span class="var">XYZ(0, -720, 0)</span> still valid in this case? Certainly not, as Lara’s head is now much lower on the Y axis and is even protruded a bit forward. Surely, we need a system which can spawn particles not merely from the base position / pivot of a given object, but rather at the exact position of a specified mesh of the object, respecting also the animation / rotation of the mesh.<br><br>
    Indeed, such a system exists, and that’s precisely what the complementary <span class="var">part.emitterNode</span> field is for. This field works in tandem with the <span class="var">part.emitterIndex</span> field we have already learned about in the previous section.<br><br>
    The <span class="var">part.emitterNode</span> field can hold an integer between <span class="var">0</span> and <span class="var">31</span>, indicating the mesh index from the emitter item (32 is the maximum of rendered meshes a moveable item can have, thus the highest possible index is 31). It can also hold the default value <span class="var">-1</span>, indicating no mesh index (the item’s pivot point is used instead). This field is only functional when a valid <span class="var">emitterIndex</span> has also been specified, otherwise it’s simply ignored. Additionally, if the value for <span class="var">emitterNode</span> is larger than the highest mesh index on the given moveable item, the <span class="var">part.emitterNode</span> value will be clamped to the actual highest mesh index (so effectively, the range goes from 0 to the total number of meshes of the moveable’s object slot, be it LARA, SKELETON or BADDY_2).<br><br>
    If <span class="var">part.emitterNode</span> is specified (along with a valid <span class="var">part.emitterIndex</span>), the particle position offsets are based <u>around the chosen mesh of the moveable</u>, instead of its pivot point (base position). These offsets additionally involve the rotation of the mesh in various animations, meaning that the ultimate particle position offset depends on both position and rotation of the mesh in question (for example, if an enemy is swinging his sword, by finding the right offsets, you can make particles spawn <u>precisely</u> on the edge of the blade, regardless of how fiercely it’s being swung around by the enemy).<br><br>
    Due to a valid <span class="var">part.emitterIndex</span> being a prerequisite for setting the <span class="var">part.emitterNode</span> field, it is a rare example of a field that must be assigned to in a <u>specific order</u> (meaning you should assign an <span class="var">emitterIndex</span> first, then proceed to assign the <span class="var">emitterNode</span> afterwards).<br><br>
    <h4>Replicating AddEffect with part.emitterNode</h4>
    If you have ever used the <span class="var">AddEffect=</span> command in TRNG, hopefully you already can see the connections between that feature and the <span class="var">part.emitterNode</span> functionality. The <span class="var">part.emitterNode</span> field does what the <span class="var">JointType</span> field did in <span class="var">AddEffect=</span>, while the <span class="var">part.pos</span> vector works equivalently to the <span class="var">DispX</span>, <span class="var">DispY</span>, <span class="var">DispZ</span>. One huge difference in comparison to <span class="var">AddEffect=</span> is that you are no longer limited to a hardcoded set of particles effects, like blood, flames, smoke or waterfall mist. You now have the freedom to define <u>any</u> kind of particle effect you can come up with, with any color, sprite, size, position! Therefore, the plugin allows much more versatility than TRNG AddEffects, being more generalized and flexible.<br><br>
    Here is a quick example script demonstrating a simple effect that sets our poor Lara’s head on fire. We use the handy <span class="var">getLaraIndex()</span> to set Lara’s Tomb4 index to the <span class="var">part.emitterIndex</span> field. The head mesh is at index 14 in the LARA / LARA_SKIN slot and that’s what we assign to the <span class="var">part.emitterNode</span> field. The particle effect is a flame effect with the standard fire sprite (0), but I made it blue-colored just for the sake of demonstrating the customizability (colored fire, the dream of many TRLE builders across the years)!
    <div class="code">
      <button class="btn" onclick="copyCode(this)"><span class="tooltip">Copy to clipboard</span><img src="clipboard.png"></button>
      local firehead<br><br>
      local function fireheadInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(firehead)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- notice we assign emitterIndex first, emitterNode second</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterIndex = getLaraIndex()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterNode = 14 <span class="com">-- Lara's head mesh</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = randomInt(20, 27)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = randomInt(192, 255)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeEnd = part.sizeStart / 8<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeIn = 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeOut = 10<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = 48<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.g = randomInt(80, 128)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.b = 255<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd.r = 32<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd.g = randomInt(160, 224)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd.b = randomInt(192, 255)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.x = randomFloat(-32, 32)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.y = randomFloat(-32, 32)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.z = randomFloat(-32, 32)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.x = randomFloat(-4, 4)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.y = randomFloat(-16, -12)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.z = randomFloat(-4, 4)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.rot = degToRad(randomInt(0, 359))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.rotVel = degToRad(randomNegate(randomFloat(4, 8)))<br>
      end<br><br>
      firehead = createGroup(fireheadInit, nil)
    </div>
    <img class="fig" src="ch1_5/ch15_firehead.gif"><br>
    Of course, <span class="var">part.emitterNode</span>, like pretty much any other particle field, can also be assigned a random value. The highest mesh number in the LARA slot is the head mesh 14, so we can assign any random integer between 0 and 14. Try it!
    <div class= "code">
      part.emitterNode = randomInt(0, 14)
    </div>
    <img class="fig" src="ch1_5/ch15_firerandom.gif"><br>
    Now that’s something you couldn’t easily pull off with AddEffects in TRNG, could you? We will revisit this randomized mesh spawn idea for something pretty cool later on!<br>
    <hr>
    <a name="id4"><h3>Particle acceleration</h3></a>
    Acceleration is the third vector property posessed by particles, after <a href="Chapter1.html#id6">position</a> and <a href="Chapter1.html#id10">velocity</a>.<br><br>
    The same way velocity is the change to position over time, acceleration is the change to velocity over time. On each frame, any non zero acceleration on any axis is applied cumulatively to velocity (just as velocity is applied cumulatively to position each frame). But what is acceleration even useful for? In physics, acceleration is generally the result of some force acting on an object. If an object is motionless or moving at a constant velocity in a straight line, we say it does not experience any acceleration. This can be either because no force is acting upon it or because all of the forces are mutually cancelling themselves out, resulting in a net force of zero. Differently, if an object changes its speed, curves or starts moving in a different direction, it is due to acceleration.<br><br>
    <h4>How to understand acceleration</h4>
    The most approachable and easy to understand example for accelaration is that of gravity making an object fall to the ground. In this case, the force of Earth’s gravity pulls the object towards the ground, resulting in downwards acceleration (this is of course Newton’s understanding of gravity, Einstein’s general relativity views it instead as the warping of space-time caused by mass, but I digress). Of course, acceleration is a 3D vector, meaning we are not limited to just the force of gravity pointing downwards, but it can simulate objects in gravitational orbit around a celestial body. We can also imagine other scenarios where an object accelerates or decelerates in some direction, due to some force acting upon it (not only gravity).<br><br>
    Another easily understood example is that of driving a vehicle: hitting the gas pedal makes the vehicle accelerate, hitting the brakes makes it decelerate (slow down). Though it may not seem like it at first, steering the vehicle left and right is also a form of acceleration (a change in moving direction = a change in velocity = acceleration)!<br><br>
    Here are some more examples from real life. If a round object slows down to a halt when rolling on a flat surface, it is because the friction force (a vector opposing the velocity vector) makes it slowly decelerate until coming to a rest. If the object drops into a liquid, then we have the force of buoyancy trying to push the object upwards, against gravity pulling it downwards. If the object is less dense than the surrounding liquid (if the mass of the object is less than the mass of the liquid displaced by the object), it will float to the top (buoyancy wins). Otherwise if it’s more dense, it will sink to the bottom (gravity wins). You can see this with some fruits or vegetables, some of them will float in water when being washed, others will sink. Apart from that, in liquids, objects tend to move slower than in air. This is another manifestation of friction (de-accceleration), slowing the object down. For this reason, items reach a constant moving speed faster when moving through liquids than through air (the increased friction cancels any further acceleration on the object). I’m sure you can find your own examples of various forces acting and counter-acting on objects, resulting in acceleration and deceleration of objects in motion.<br><br>
    As an interesting bit of insight, acceleration is also what makes objects take a curved trajectory through space. Objects experiencing zero acceleration will always move in a straight line (or in the special case where velocity is also zero, remain motionless). Going again with gravity as our exemplary force, imagine throwing a ball forwards, perfectly horizontally. If there was no gravity on Earth, it would have flown straight ahead, never touching the ground. However, gravity makes it curve away from this straight path, making it land on the ground. This curving, due to gravitational acceleration is also what keeps planets in orbit around our Sun. They are constantly experiencing a falling motion around it, yet they have a trajectory curved significantly enough to remain stable and not fall towards it. They are quite literally falling endlessly, when you think about it!<br><br>
    Alright, enough physics lessons for today, back to our particles.<br><br>
    <h4>Particle acceleration vector</h4>
    In the particle system, a particle’s acceleration vector can be accessed through the <span class="var">part.accel</span> field. Similarly to <span class="var">part.pos</span> and <span class="var">part.vel</span>, it is a 3D vector with X, Y and Z components:
    <div class="code">
      part.accel.x <span class="com">-- X acceleration</span><br>
      part.accel.y <span class="com">-- Y acceleration</span><br>
      part.accel.z <span class="com">-- Z acceleration</span>
    </div>
    <a name="gravity"></a>A frequent (but by no means exclusive) use for acceleration is to simulate gravity acting on particles. The TR engine has a <strong>gravity constant</strong> of <strong>6 units per frame</strong>. Falling items (e.g. Lara, rollingballs, grenades, flares, gunshells) whilst falling, all accelerate downwards at a rate of 6 units per frame. This simply means that 6 is added over and over to the falling item’s Y velocity each frame. Therefore, if you want to match the default TR engine gravity with particles, you can use a positive <span class="var">part.accel.y</span> of <span class="var">6</span>, whilst keeping the X and Z components at the default <span class="var">0</span>:
    <div class="code">
      part.accel.y = 6 <span class="com">-- TR engine gravity</span><br>
      <span class="com">--part.accel.x = 0</span><br>
      <span class="com">--part.accel.z = 0</span><br>
      <span class="com">-- X and Z accel are implicitly set to 0</span>
    </div>
    Important to note here: particles by themselves do not check collision with room geometry, unless you explicitly tell them to. Hence if you try this, you will see particles falling through the floor, as if it wasn’t there. This goes beyond the scope of the current chapter, but we’ll learn how we can make particles collide with and bounce off of floors and walls, once we get to <strong>particle functions</strong> in <strong>Chapter 3</strong>.<br><br>
    Another case for using Y acceleration is for simulating fire-like effects. Fire particles in TR often accelerate upwards, which simulates the flame getting hotter towards the top and flowing faster due to convection (hotter air rising faster than colder air). We could improve the look of the <span class="var">firehead</span> script from last section by removing initial Y velocity from the particles and replacing it with acceleration (this is actually used in the <span class="var">firehead.lua</span> template module):
    <div class="code">
      part.vel.x = randomFloat(-4, 4)<br>
      part.vel.z = randomFloat(-4, 4)<br>
      part.accel.y = randomFloat(-1.25, -1.0)
    </div>
    <a name="slowdown"><h4>Acceleration “slowdown” trick</h4></a>
    I will not elaborate further on topic of acceleration, if you understood everything above, there is not much else to add. Surely, you will figure out your own uses for setting acceleration on particles. However, I would like to show a neat little trick you can set up in the init function, which is making particles start out with a fast initial speed and gradually slow down, reaching a stop at the end of their life.<br><br>
    If we give particles randomized velocity on <span class="var">x, y, z</span> and random <span class="var">part.lifeSpan</span>:
    <div class="code">
      part.lifeSpan = randomInt(40, 60)<br><br>
      part.vel.x = randomFloat(-70, 70)<br>
      part.vel.y = randomFloat(-70, 70)<br>
      part.vel.x = randomFloat(-70, 70)
    </div>
    We can conveniently make them fully stop moving upon reaching the end of their respective <span class="var">part.lifeSpan</span> with the following code:
    <div class="code">
      part.accel.x = -part.vel.x / part.lifeSpan<br>
      part.accel.y = -part.vel.y / part.lifeSpan<br>
      part.accel.z = -part.vel.z / part.lifeSpan<br>
    </div>
    or more concisely, by using <strong>vector arithmetic</strong> directly on the 3D vector <span class="var">part.vel</span> (this will be explained later):
    <div class="code">
      part.accel = -part.vel * (1 / part.lifeSpan)<br>
    </div>
    <img class="fig" src="ch1_5/ch15_accel.gif"><br>
    As a result, we’ll obtain particles that are shot out fast, but will slow down completely as they reach the end of their life span (there’s a metaphor for something somewhere in there, I feel…). This results in a kind of “friction” in the particle motion. Note that this is not physically accurate friction, but it’s close enough for most purposes. This trick will work regardless of the particle’s starting velocity and life, which makes it quite convenient. The pre-calculated acceleration values will cause the particles to always reach 0 velocity as they die, regardless of their direction or lifespan. However, this will no longer work as intended, if the velocity is ever changed in the update function. For that case, there is another “friction” technique, which will be demonstrated in the chapter about update functions.<br>
    <hr>
    <a name="id5"><h3>Particle size ratio factor</h3></a>
    Recall when I was explaining how <a href="Chapter1.html#id4">particle size</a> works for sprite particles. What I mean is the notion of the “particle square”, i.e. the square on which the sprite texture is mapped onto. The particle size refers to the size of this square. I was not really telling the full story, though… more generally, the sprites are mapped onto rectangles. A square is simply a special case of a rectangle, where all its four sides are the same length.<br><br>
    Immediate question – is there something about a particle that determines whether it will be a square or rectangle? As a matter of fact, there is! The particle field <span class="var">part.sizeRatio</span> controls the proportions of the rectangle onto which the particle texture is mapped. It holds a floating point number between -1 and 1, with the default value being 0.<br><br>
    As you may already guess, the particle is a perfectly even square when <span class="var">part.sizeRatio</span> is equal to 0. Outside of the default, though, this property is a kind of ratio between the horizontal and vertical size of the rectangle onto which the sprite texture is mapped. The exact way it works is conveyed through the following formulae:<br><br>
    <span class="var">
      xSize = (sizeRatio + 1) / 2<br>
      ySize = 1 - xSize
    </span><br><br>
    Here is a simple tool demonstrating this logic. Use the <span class="var">sizeRatio</span> slider below and examine how it affects the shape of the square / rectangle:<br>
    <table cellpadding="0" cellspacing="0" style="border: none; margin-left: auto; margin-right: auto; user-select: none">
      <tr>
        <td style="width: 380px">
          <ul style="list-style-type: none; font-family: 'Consolas'">
            <li><span class="var">xSize = (sizeRatio + 1) / 2</span></li>
            <li><span class="var">ySize = 1 - xSize</span></li>
            <li>&nbsp;</li>
            <li>
              <strong>sizeRatio</strong>
              <input id="rat" type="range" value="0" min="-100" max="100" style="width: 150px">
              <span id="val-rat">0.0</span>
            </li>
            <li>
              <strong>xSize</strong>:&nbsp;<span id="val-x">0.5</span>
            </li>
            <li>
              <strong>ySize</strong>:&nbsp;<span id="val-y">0.5</span>
            </li>
          </ul>
        </td>
        <td>
          <canvas id="ratio" style="margin-left: 10px">
            <script src="ch1_5/ratio.js"></script>
          </canvas>
        </td>
      </tr>
    </table>
    When <span class="var">sizeRatio</span> is -1, the <span class="var">xSize</span> is 0, meaning the particle is squished into an infinitely thin, vertical line. At <span class="var">sizeRatio</span> 1, the <span class="var">ySize</span> is 0 – the particle size is squashed into a horizontal line. In between, you get various rectangular shapes, including the default square shape at <span class="var">sizeRatio = 0</span>.<br><br>
    This property can be used to give particles variation in proportions (squished and stretched particles). The squeezing and stretching is applied prior to rotation of the texture, allowing you to create thin, “splinter-like” particles with any round sprite texture:
    <div class="code">
      part.spriteIndex = 11 <span class="com">-- "shine" sprite texture</span><br><br>
      part.sizeStart = randomInt(150, 300)<br>
      part.sizeEnd = part.sizeStart<br><br>
      part.rot = degToRad(randomInt(0, 359))<br><br>
      part.sizeRatio = 0.8
    </div>
    <img class="fig" src="ch1_5/ch15_thin.gif"><br>
    When you pair this <span class="var">sizeRatio</span> property with update functions, you can even animate this squeezing and stretching over time (but update functions are something that one of the upcoming chapters will be concerned with).<br>
    <hr>
    <a name="id6"><h3>Particle color fading time</h3></a>
    When I described the way the <a href="Chapter1.html#cols">color properties</a> <span class="var">part.colStart</span> and <span class="var">part.colEnd</span> work, I said that the particles will linearly transition between the start color and end color during their life. As it turns out, this isn’t the full truth of the matter, either. This transistion from the start color to end color can also occur in a shorter duration than the entire lifespan.<br><br>
    The sprite particle property <span class="var">part.colFadeTime</span> describes the duration (in game ticks) over which this color transition will take place. By default, this field is equal to <span class="var">0</span>. This makes the particles behave exactly as was explained in Chapter 1, i.e. going between <span class="var">part.colStart</span> and <span class="var">part.colEnd</span> during the full <span class="var">part.lifeSpan</span> of the particle. Therfore,
    <div class="code">
      part.colFadeTime = 0
    </div>
    behaves the same as if we put:
    <div class="code">
      part.colFadeTime = part.lifeSpan
    </div>
    Differently, if we set this property to a non-zero value, it can make the particles complete this color transition sooner.<br><br>
    You can set both positive and negative values for this field, though they work differently.<br><br>
    Positive values mean that the particle should begin transitioning immediately after being spawned and end the transition within the duration indicated by <span class="var">part.colFadeTime</span> (which is smaller than <span class="var">part.lifeSpan</span> itself). After completing the transition, the particle remains at <span class="var">part.colEnd</span> for the rest of its life duration. When using positive values, <span class="var">part.colFadeTime</span> must be larger than zero, but less or equal to <span class="var">part.lifeSpan</span>, i.e. satisfy the condition:<br><br>
    <span class="var">0 &lt; colFadeTime &lt;= lifeSpan</span><br><br>
    It will get clamped to the <span class="var">lifeSpan</span> maximum if you try setting a larger value, anyway. As an example, if you want particles to finish changing color halfway through their life span, you can do:
    <div class="code">
      part.lifeSpan = randomInt(96, 128)<br>
      part.colFadeTime = part.lifeSpan / 2 <span class="com">-- particle will fade color from start to half of lifeSpan</span>
    </div>
    On the other side, we have negative values. These are a bit more awkward to grasp, but they mean the particle should start transitioning from <span class="var">part.colStart</span> to <span class="var">part.colEnd</span> when the particle has <span class="var">-(colFadeTime)</span> (the negative of the negative, i.e. positive) game ticks of life left. This means that the particle initially remains at <span class="var">part.colStart</span> and does not begin transitioning into <span class="var">part.colEnd</span> until it has been alive for <span class="var">(lifeSpan&nbsp;+&nbsp;colFadeTime)</span> game ticks, with <span class="var">colFadeTime</span> being some negative integer (thus subtracting itself from the total <span class="var">lifeSpan</span> value). The particle will complete the whole color transition exactly when reaching the end of its life. The negative values must also satisfy the condition:<br><br>
    <span class="var">0 &lt; -(colFadeTime) &lt;= lifeSpan</span>
    <div class="code">
      part.lifeSpan = randomInt(96, 128)<br>
      part.colFadeTime = -(part.lifeSpan / 4) <span class="com">-- particle color fading will be delayed until the remaining quarter of lifeSpan</span>
    </div>
    This field has a more niche purpose and you may not ever find yourself needing to use it. It’s mainly there to replicate a very similar functionality in original TR4 particles, that had this color fading time, that lasted shorter than the lifespan of the particle (e.g. it was used for fire particles). Despite that, it does give some limited ability to fine-tune the coloration of your particle effects.<br><br>
    The more robust way to manage the color of particles through their lifetime is using the <span class="var">part.colCust</span> property within update functions, which again, will be explained in a later chapter.<br>
    <hr><br>
    This concludes the main portion of <strong>Chapter 1</strong>. We have learned how to influence the spawn and about few more interesting particle properties. The most significant was discovering how to make particles spawn around moveables with <span class="var">part.emitterIndex</span> and how to replicate TRNG AddEffects feature by making use of the <span class="var">part.emitterNode</span> field.<br><br>
    In the upcoming <strong>Chapter 2</strong>, we will discuss what tools the plugin provides to help in catching errors and issues with your Lua code. Then, in <strong>Chapter 3</strong> we’ll finally take a dive into the much hyped update functions. Hope to see you there as well!<br><br><br>
    Before moving onto the next topic, if you would like to learn more advanced (and cool) tricks involving init functions, the bonus section below might be for you. I will warn that you will probably like it more if you enjoy math at least somewhat.<br>
    If that does not pique your interest, feel free to move on to the next chapter:
    <table width=100%>
      <tr>
      <td></td>
      <td style="text-align: right"><a href="Chapter2.html" ><strong>NEXT&nbsp;&gt;&gt;&gt;</strong></a></td>
      </tr>
    </table>
    <hr>
    <a name="id7"><h3>Bonus: Geometric spawning formations</h3></a>
    In our dust particle script we have been focusing on for most of <strong>Chapter 1</strong>, we were spawning the particles randomly within a rectangular box of certain dimensions. Let’s admit that a box is a rather boring shape. By applying some knowledge of math, it’s not difficult to spawn particles in a multitude of different spatial arrangements, such as a cylinder, spiral, helix, sphere, or any other easily defined mathematical shape. We will go through a few examples in the following section.<br><br>
    <h4>Cylinder formation</h4>
    Our objective is to change the spawning shape of the particles from a rectangular box to a round cylinder with a given radius. A cylinder has a single, round side and a vertical height.<br>
    <img class="fig" src="ch1_5/cylinder.png"><br>
    Let’s remind ourselves a bit of math from school. A circle is a 2D shape made up of all points that are an equal distance away from a central point. We call this distance the <i>radius</i> and usually denote it with the letter <span class="var">r</span>. Why am I talking about circles? Don’t worry, I’ll get to that soon.<br>
    <img class="fig" src="ch1_5/circle.png"><br>
    How do define a circle with radius <span class="var">r</span>? There are two common math equations for it. The first of them involves the coordinates of the circle’s central point (<span class="var">xp</span>, <span class="var">yp</span>) in the following equality:<br><br>
    <span class="var">
      &nbsp;&nbsp;&nbsp;&nbsp;(x - xp)² + (y - yp)² = r²
    </span><br><br>
    All the value pairs of (<span class="var">x</span>, <span class="var">y</span>), which satisfy the above equality, describe the circle of radius <span class="var">r</span>, centered at the point (<span class="var">xp</span>, <span class="var">yp</span>). Unfortunately, this equality of a circle will not be very useful for our purposes, as it does not exactly tell us what <span class="var">x</span> and <span class="var">y</span> are (there are infinitely many pairs of <span class="var">x</span> and <span class="var">y</span>, which will satisfy the equality, anyway).<br><br>
    Another way of defining a circle is with the trigonometric functions, <span class="var">cos()</span> and <span class="var">sin()</span> and some angle, which we can designate with <span class="var">ang</span>. We then use the following equations for getting the coordinates values of <span class="var">x</span> and <span class="var">y</span>:<br><br>
    <span class="var">
      &nbsp;&nbsp;&nbsp;&nbsp;x = r * cos(ang) + xp<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y = r * sin(ang) + yp
    </span><br><br>
    As the angle <span class="var">ang</span> sweeps from 0 to 2&pi; radians (0 to 360 degrees), this pair of equations will trace out the circle of radius <span class="var">r</span>, centered at (<span class="var">xp</span>, <span class="var">yp</span>) through the <span class="var">x</span> and <span class="var">y</span> coordinates (which are dependent on the value of <span class="var">ang</span>). We can say that the angle <span class="var">ang</span>, defined to be somewhere in the range 0 to 2&pi;, serves as the <i>parametric variable</i> (or parameter) for these equations. If you don’t feel the intuition behind it yet, perhaps the interactive demo below will help:<br><br>
    <table cellpadding="0" cellspacing="0" style="border: none; margin-left: auto; margin-right: auto; user-select: none">
      <tr>
        <td style="width: 380px">
          <ul style="list-style-type: none; text-align: center; font-family: 'Consolas'">
            <li><span class="var">x = r * cos(ang)</span></li>
            <li><span class="var">y = r * sin(ang)</span></li>
            <li>&nbsp;</li>
            <li>
              <strong>&nbsp;r&nbsp;</strong>
              <input id="radius" type="range" value="120" min="0" max="160" style="width: 160px">
              <span id="val-r">6.0</span>
            </li>
            <li>
              <strong>ang</strong>
              <input id="angle" type="range" value="225" min="0" max="360" style="width: 150px">
              <span id="val-ang">225</span>°
            </li>
          </ul>
        </td>
        <td>
          <canvas id="circle" style="margin-left: 10px">
            <script src="ch1_5/circle.js"></script>
          </canvas>
        </td>
      </tr>
    </table>
    These so-called <i>parametric equations</i> for the circle are exactly what we will need to spawn our particles in a cylindrical or ring shape.<br><br>
    If you recall the last chapter, we randomized the position of dust particles with randomly generated numbers in the variables <span class="var">dx</span>, <span class="var">dy</span>, <span class="var">dz</span>.
    <div class="code">
      local dx = randomFloat(-512, 512)<br>
      local dy = randomFloat(-512, 512)<br>
      local dz = randomFloat(-512, 512)<br><br>
      part.pos.x = dx<br>
      part.pos.y = dy<br>
      part.pos.z = dz
    </div>
    What we did here is we used the <span class="var">dx</span>, <span class="var">dy</span>, <span class="var">dz</span> variables as offsets from the base position, which could be the position of the emitter object. In this case, we were affecting all 3 dimensions, XYZ, in a completely random way, giving rise to a 3D box inside of which the particles could spawn.<br><br>
    Now, let’s take another look at the parametric equations for the circle:<br><br>
    <span class="var">
      &nbsp;&nbsp;&nbsp;&nbsp;x = r * cos(ang) + xp<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y = r * sin(ang) + yp
    </span><br><br>
    and forget the central point offsets for a moment:<br><br>
    <span class="var">
      &nbsp;&nbsp;&nbsp;&nbsp;x = r * cos(ang)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y = r * sin(ang)
    </span><br><br>
    we see the <span class="var">x</span> and <span class="var">y</span> coordinates are correlated with the variables <span class="var">r</span> for the radius and <span class="var">ang</span> for the angle. If we use a specific value for <span class="var">r</span>, like 10, we get a point somewhere on the circle of that radius, depending on the provided value for <span class="var">ang</span>. Here’s where we can do something interesting.<br><br>
    Let’s create <span class="var">ang</span> as a variable in Lua and give it a random value between 0 and 2 pi. Of course, to make things easier for ourselves, we can use the <span class="var">degToRad()</span> utility function to specify values in degrees, since the <span class="var">cos()</span> and <span class="var">sin()</span> functions are designed to work with radians, not degrees.
    <div class="code">
      local ang = degToRad(randomInt(0, 359)) <span class="com">-- get random angle between 0 and 359 degrees</span>
    </div>
    And now we can use the parametric equations for the circle to get the x and y offsets. We can name them <span class="var">cx</span> and <span class="var">cy</span> for our example. We will also use a radius <span class="var">r</span> of 1024. Here’s what we should have:
    <div class="code">
      local ang = degToRad(randomInt(0, 359)) <span class="com">-- get random angle between 0 and 359 degrees</span><br>
      local rad = 1024 <span class="com">-- radius</span><br><br>
      local cx = rad * cos(ang)<br>
      local cy = rad * sin(ang)
    </div><br>
    You might notice that we have only two offset variables this time, <span class="var">cx</span> and <span class="var">cy</span>. Without the central point <span class="var">(xp, yp)</span>, these variables describe the x and y coordinates of a circle at the origin point (0, 0). In global coordinates, this will very likely be outside of your level map, which is a bummer! Remember, about <span class="var">part.emitterIndex</span>, though? If we assign some moveable index to it, then the <span class="var">part.pos</span> coordinates will become offsets from the moveable object. We’ll rely on this approach to make <span class="var">cx</span> and <span class="var">cy</span> offsets from the emitter moveable.<br><br>
      We have to assign the <span class="var">cx</span> and <span class="var">cy</span> to the <span class="var">x</span> and <span class="var">y</span> of the <span class="var">pos</span> vector. But that’s just one of the options. We could perhaps assign it to <span class="var">z</span> and <span class="var">y</span>. Ultimately, it only depends which direction we want the cylinder to face. If we decide to do this:
    <div class="code">
      part.pos.x = cx<br>
      part.pos.y = cy<br>
      part.pos.z = 0
    </div>
    then the cylinder’s circumference will be in the XY plane, so it will be vertically oriented. If we instead do this:
    <div class="code">
      part.pos.x = 0<br>
      part.pos.y = cx<br>
      part.pos.z = cy
    </div>
    then it will also be vertically oriented, but in the ZY plane, perpendicular to the first example. Finally, when we do this:
    <div class="code">
      part.pos.x = cx<br>
      part.pos.y = 0<br>
      part.pos.z = cy
    </div>
    then it will be in the XZ plane, oriented horizontally.
    <br><br>
    Okay, now we have a circular ring… how do we get to a cylinder from here? On that one axis that did not receive the circle coordinate offsets (<span class="var">cx</span>, <span class="var">cy</span>), let’s calculate a third, random offset with <span class="var">randomInt()</span> or <span class="var">randomFloat()</span>, to add depth to the circle and form the cylinder’s “side surface”. Let’s assume we decided to go with the circle in the horizontal XZ plane. We will thus add the random offset to the <span class="var">y</span> coordinate, while adding <span class="var">cx</span> to <span class="var">x</span> and <span class="var">cy</span> to <span class="var">z</span> (it might be better to rename <span class="var">cy</span> to <span class="var">cz</span> in that case).
    <div class="code">
      part.pos.x = cx<br>
      part.pos.y = randomFloat(-512,512)<br>
      part.pos.z = cy
    </div>
    Now let’s create a proper particle group and init function around that. The particles we will use will have the bubbles sprite texture (13), a turquise color and no velocity. Also, we’ll use <span class="var">part.emitterIndex</span> to make the particles spawn around an emitter item. I used an invisible CAMERA_TARGET nullmesh with ID 3.
    <div class="code">
      <button class="btn" onclick="copyCode(this)"><span class="tooltip">Copy to clipboard</span><img src="clipboard.png"></button>
      local bubbles<br><br>
      local function bubbleInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(bubbles) <span class="com">-- create a particle of the "bubbles" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterIndex = getTombIndex(3) <span class="com">-- emitter item with ID 3</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 3<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = randomInt(48, 80)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeEnd = part.sizeStart<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.g = randomInt(224, 255)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.b = randomInt(224, 255)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd = part.colStart<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- cylindrical spawning formation</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local ang = degToRad(randomInt(0, 359)) <span class="com">-- get random angle between 0 and 359 degrees</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local rad = 1024 <span class="com">-- radius</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local cx = rad * cos(ang)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local cy = rad * sin(ang)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.x = cx<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.y = randomFloat(-512, 512)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.z = cy<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 13 <span class="com">-- "bubble" sprite texture</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeIn = 30 <span class="com">-- fade in for 1 second</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeOut = 30 <span class="com">-- fade out for 1 second</span><br>
      end<br><br>
      bubbles = createGroup(bubbleInit, nil)
    </div>
    If we run the above particle effect in the level, we should get a cylindrical ring of turquoise bubbles around the emitter object.<br><br>
    <img class="fig" src="ch1_5/ch15_bubbles1.jpg"><br><br>
    You can now customize the offset variables however you like. For example, we can randomize the <span class="var">r</span> value, which will result in the cylindrical ring having some depth.
    <div class="code">
      local rad = randomInt(512, 1024)
    </div>
    We can also choose to add some velocity on the Y axis, so the bubbles will scroll upwards, along the cylinder walls:
    <div class="code">
      part.vel.y = -16
    </div><br>
    <img class="fig" src="ch1_5/ch15_bubbles2.gif"><br>
    I can picture such bubbles working quite nicely in a circular aquatic tank with fishes or a bio-reactor in a sci-fi research facility…<br><br>
    You can add more of your own “flavor” to this effect, but I shall leave it here.<br>
    <hr>
    <a name="helix"><h3>Helix and spiral formations</h3></a>
    The terms <i>spiral</i> and <i>helix</i> are often used interachangably to some degree. However, stricly speaking, they mean two different things, at least in the world of mathematics. A spiral is a flat shape that curves (spirals) around a point in 2D outwards (or inwards, depending on how you look at it). Here are some examples of spirals:<br><br>
    A helix is also a curved shape, but one that exists in 3D space. It resembles a spring or corkscrew:<br><br>
    Both have a similar connotation of going round and round, but as you see, they are not quite the same thing.<br><br>
    For this example, we will create an animated helix of particles. Later on, we will make some small adjustments to create a spiral effect, too.<br><br>
    <h4>The circle parametric equations, again</h4>
    We continue working with parametric equations for a circle. Let’s take another look at how we used them in the cylinder / ring example from earlier:
    <div class="code">
      local ang = degToRad(randomInt(0, 359)) <span class="com">-- get random angle between 0 and 359 degrees</span><br>
      local rad = 1024 <span class="com">-- radius</span><br><br>
      local cx = rad * cos(ang)<br>
      local cy = rad * sin(ang)
    </div>
    We were picking a random number between 0 and 359 to get a random angle on each frame. But what if this angle was not a random value, but changed in a predictable way? Say, if it was derived from the game tick value, for instance.<br><br>
    The <span class="var">getGameTick()</span> function was already brought to our attention, in the earlier section on <a href="#interval">spawn intervals</a>. There, we used it to spawn particles at precise time intervals. Now, we’ll be using it for a different purpose, albeit still related to a repeating time pattern. What if we assigned the value returned from <span class="var">getGameTick()</span> to the angle variable <span class="var">ang</span>? Let’s examine the following code:
    <div class="code">
      local ang = getGameTick() <span class="com">-- get number of elapsed game ticks</span><br>
      local rad = 512 <span class="com">-- radius</span><br><br>
      local cx = rad * cos(ang)<br>
      local cy = rad * sin(ang)
    </div>
    How will this affect the resulting values for the variables <span class="var">cx</span> and <span class="var">cy</span>?<br>
    Firstly, we should recognize that the trigonometric functions <span class="var">cos()</span> and <span class="var">sin()</span> are periodic, meaning they repeat with a certain interval, as you give them increasing argument values. Secondly, the trigonometric functions assume that whatever argument we give to them is expressed in radians (not degrees).<br>
    <img class="fig" src="ch3/sin_plot.png"><br>
		<img class="fig" src="ch3/cos_plot.png"><br><br>
    So, if we follow what the code says, then as the game tick counter starts counting up: 0, 1, 2, 3, 4, … the functions will receive angles of 0 radians, 1 radians, 2 radians… and that’s a very fast increment of angles! As a reminder, a full 360 degree angle is equal to exactly 2&pi; radians, so the whole circle path would be completed in a bit over 6 game ticks (6.28&nbsp;radians&nbsp;/&nbsp;1&nbsp;radian-per-frame&nbsp;=&nbsp;6.28 frames). On top of not fitting perfectly into the engine’s fps, that’s way too quick for a smooth, non-jerky animation!<br><br>
    Let’s try to slow it down somewhat. First of all, we’ll wrap our <span class="var">getGameTick()</span> call inside a <span class="var">degToRad()</span> call, like so (you could also split it into separate steps / variables, if that makes it more clear):
    <div class="code">
      local ang = degToRad(getGameTick()) <span class="com">-- get game ticks and convert them to radian values</span><br>
    </div><br>
    We’ll analyse how much time it takes to complete the circle now. As the game ticks go up, we get increments of 1 degree to the angle. We can conclude that it will take 360 game ticks to complete the circle. 360 frames divided by 30 fps gives us… 12 seconds! This time around, it’s a tad too slow, if you ask me. Let’s multiply our current result by 6, which should make the circle complete in exactly 2 seconds:
    <div class="code">
      local ang = degToRad(getGameTick()) * 6 <span class="com">-- get game ticks and convert to radian values, multiply result by 6</span><br>
    </div><br>
    Let’s now assemble the above into a full-fledged particle effect. If we just use the offsets on static particles with no velocity, the result will be a particle trail that moves along a circle:
    <div class="code">
      <button class="btn" onclick="copyCode(this)"><span class="tooltip">Copy to clipboard</span><img src="clipboard.png"></button>
      local helix<br><br>
      local function helixInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(helix) <span class="com">-- create a particle of the "helix" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterIndex = getTombIndex(3) <span class="com">-- emitter item with ID 3</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = 160<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeEnd = part.sizeStart / 4<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = 255<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.g = 128<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.b = 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd = part.colStart<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- helical spawning formation</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local ang = degToRad(getGameTick()) * 6 <span class="com">-- get game ticks and convert to radian values, multiply by 6</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local rad = 512 <span class="com">-- radius</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local cx = rad * cos(ang)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local cy = rad * sin(ang)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.x = cx<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.y = cy<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.z = 0<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 11 <span class="com">-- "shine" sprite texture</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeIn = 0 <span class="com">-- no fade in</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeOut = 30 <span class="com">-- fade out for 1 second</span><br>
      end<br><br>
      helix = createGroup(helixInit, nil)
    </div><br>
    <img class="fig" src="ch1_5/ch15_spiral1.gif"><br>
    Don’t get me wrong, this is a neat effect on its own (it looks a bit like a “loading” icon), but we specifically wanted a 3D helix (i.e. a spring shape). Do obtain one, we need to add velocity on the axis perpendicular to our circle, which in this case is the Z axis. And we’ll extend the <span class="var">lifeSpan</span> by a few more seconds, too:
    <div class="code">
      <button class="btn" onclick="copyCode(this)"><span class="tooltip">Copy to clipboard</span><img src="clipboard.png"></button>
      local function helixInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(helix) <span class="com">-- create a particle of the "helix" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterIndex = getTombIndex(3) <span class="com">-- emitter item with ID 3</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 6<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = 160<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeEnd = part.sizeStart / 4<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = 255<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.g = 128<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.b = 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd = part.colStart<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- helical spawning formation</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local ang = degToRad(getGameTick()) * 6 <span class="com">-- get game ticks and convert to radian values, multiply by 6</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local rad = 512 <span class="com">-- radius</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local cx = rad * cos(ang)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local cy = rad * sin(ang)<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.x = cx<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.y = cy<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos.z = 0<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel.z = 16 <span class="com">-- velocity on perpendicular Z axis</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 11 <span class="com">-- "shine" sprite texture</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeIn = 0 <span class="com">-- no fade in</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeOut = 30 <span class="com">-- fade out for 1 second</span><br>
      end
    </div><br>
    <img class="fig" src="ch1_5/ch15_spiral2.gif"><br>
    Now we’re talking, so pretty!<br><br>
    Here’s an extra tidbit, if we want the helix to converge to the center at the tip, the trick is to use the negatives of <span class="var">cx</span> and <span class="var">cy</span>, divided by <span class="var">part.lifeSpan</span>, as the X and Y velocities, respectively.
    <div class="code">
      part.vel.z = 16 <span class="com">-- velocity on perpendicular Z axis</span><br>
      part.vel.x = -cx / part.lifeSpan<br>
      part.vel.y = -cy / part.lifeSpan
    </div>
    If we now “flatten” the helix by removing the Z velocity (setting it to 0 or commenting it out) and leave the X and Y velocities as they are, we actually obtain an inwards spiral effect, try it out!<br>
    <img class="fig" src="ch1_5/ch15_spiral3.gif"><br>
    An outwards spiral starting from the center can be done by not offseting the spawn position (spawning from the center 0, 0, 0), instead using un-negated <span class="var">cx</span> and <span class="var">cy</span> offsets for calculating X and Y velocity.
    <div class="code">
      <span class="com">--part.pos.x = cx</span><br>
      <span class="com">--part.pos.y = cy</span><br>
      <span class="com">--part.pos.z = 0</span><br><br>
      part.vel.x = cx / part.lifeSpan<br>
      part.vel.y = cy / part.lifeSpan
    </div>
    <img class="fig" src="ch1_5/ch15_spiral4.gif"><br>
    This demonstrates that it is possible to achieve simple “animations” with particles, by being clever with our init functions. Of course, it is not the particles themselves that are animating (notice how they are always moving in a straight line!), but the spawn positions of the particles changing over time create a frame-by-frame illusion of “spinning around”.<br><br>
    Making the particles actually travel along the curved helical/spiral path is something that can only be done through update functions (since it requires modifying the particle velocity per each frame). We will return to this topic when we talk about update functions in Chapter 3.<br>
    <hr>
    <h4>Spherical formation</h4>
    As the final shape, we will examine how you can spawn particles randomly on the surface of a sphere and inside a spherical volume. This can be useful in the creation of “energy shields”, “force fields” and the like, whatever requires a spherical dome of sorts.<br><br>
    Of course, there are some mathematical facts to lay out, first. A sphere is a shape very much related to the circle. It’s like the 3D version of the 2D circle. Likewise, a sphere is also described by some central point in 3D space, e.g. <span class="var">(xp, yp, zp)</span> and a radius <span class="var">r</span>. It’s similarly a collection of all points at equal distance <span class="var">r</span> away from some central point, but this time in 3D space. This extra dimension makes things a bit more complicated, though. We’re no longer describing a mere curve, as with a 2D circle, but rather a whole <i>surface</i>. To describe a surface (such as that of a sphere) parametrically, we need two separate angle parameters. These angles are often denoted with the greek letters <strong>&theta;</strong> (<i>theta</i>) and <strong>&phi;</strong> (<i>phi</i>). In the code, we can call them <span class="var">theta</span> and <span class="var">phi</span>, accordingly.<br><br>
    In describing a sphere, the first angle, <span class="var">theta</span>, serves the same purpose as with the angle <span class="var">ang</span> in the circle equations, describing the horizontal facing or the <i>azimuthal angle</i>. It is an angle in the range 0 to 2 pi (or 0 to 360 degrees), doing a full circle around. If you imagine the sphere as a globe, <span class="var">theta</span> can also be thought of as the longitude on a globe. As the angle <span class="var">theta</span> increases, you are travelling along the equator of the globe.<br><br>
    The second angle, <span class="var">phi</span>, describes the elevation or the <i>polar angle</i> from the plane on which the central point rests (and it’s called the <i>polar</i> angle because it brings you from the north pole to the south pole, or vice-versa). It is often in the range between -pi/2 and pi/2 (-90 to 90 degrees). With the globe analogy, <span class="var">phi</span> can be thought of as the latitude. At <span class="var">phi</span> = 0, you’re on this globe’s equator and at the extreme ends of -pi/2 and pi/2, you’re at either the south pole or north pole, respectively (which pole is which depends purely on convention, however).<br><br>
    Since we’re now dealing with 3D space, you may figure that we will be obtaining X, Y and Z coordinates from a set of parametric equations. What are these equations?<br><br>
    <span class="var">
      &nbsp;&nbsp;&nbsp;&nbsp;x = r * sin(phi) * cos(theta)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y = r * cos(phi)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;z = r * sin(phi) * sin(theta)<br>
    </span><br>
    These equations are for converting so-called <i>spherical coordinates</i>, described by <span class="var">(r, theta, phi)</span> to 3D <i>cartesian coordinates</i>, <span class="var">(x, y, z)</span>. There is more math stuff going on in them, huh? They get more complicated because on top of having one angle for describing the position on the circumference, we need a second angle for determining the elevation in the third spatial axis (in our case, the Y axis). Thus, the computation of the cartesian coordinates involves both angles in some way (apart from Y, which only depends on <span class="var">phi</span>).<br><br>
    If were working up a cold sweat over these equations already, I have some good news for you. We don’t need to use these parametric equations directly in our code (but if you really want to, go for it!). The API provides a useful built-in function called <span class="var">sphericalToCartesian(r, theta, phi)</span>. This function takes 3 arguments and returns a 3D vector value:
    <div class="code">
      local vec = sphericalToCartesian(radius, theta, phi)
    </div>
    The function’s arguments represent:
    <ul>
      <li><span class="var">radius</span> – the sphere’s radius</li>
      <li><span class="var">theta</span> – the first parametric angle <strong>&theta;</strong></li>
      <li><span class="var">phi</span> – the second parametric angle <strong>&phi;</strong></li>
    </ul>
    The function returns a coordinate vector object corresponding to the 3D cartesian <span class="var">(x, y, z)</span> coordinates from the given <span class="var">radius</span>, <span class="var">theta</span> and <span class="var">phi</span> inputs. It makes obtaining the right values for X, Y and Z much easier than writing the proper formulas manually.<br><br>
    Alright, we know we can pick any (positive) value for the radius, but what about the angles? Well, I already outlined the ranges expected for both <span class="var">theta</span> and <span class="var">phi</span> earlier.<br>
    For <span class="var">theta</span>, we need an angle between 0 and 360 degrees. We can simply copy what we did for the cylindrical formation from before. We can also including float values in-between:
    <div class="code">
      local theta = degToRad(randomFloat(0, 360)) <span class="com">-- get random angle between 0 and 360, convert to radians</span>
    </div>
    For <span class="var">phi</span>, it’s a different matter. We need an angle between -90 and 90 degrees. This is also very straightforward:
    <div class="code">
      local phi = degToRad(randomFloat(-90, 90)) <span class="com">-- get random angle between -90 and 90 degrees</span>
    </div>
    Now we just need to combine it with a particle effect to test it out. I decided to spawn several short-lived particles per frame by using a main init function <span class="var">sphereInit()</span> calling the actual particle spawning function <span class="var">sphereSpawn()</span> in a for loop (remind yourself <a href="#multispawn">manipulating particle spawnrates</a>):
    <div class="code">
      <button class="btn" onclick="copyCode(this)"><span class="tooltip">Copy to clipboard</span><img src="clipboard.png"></button>
      local sphere<br><br>
      local function sphereSpawn()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(sphere) <span class="com">-- create a particle of the "sphere" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterIndex = getTombIndex(3) <span class="com">-- emitter item with ID 3</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = 60<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeEnd = part.sizeStart * 5<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = randomInt(128, 160)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.g = randomInt(128, 160)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.b = 255<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd = part.colStart<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 11 <span class="com">-- "shine" sprite texture</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeIn = 15<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeOut = 15<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- spawn on spherical surface</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local rad = 768 <span class="com">-- radius</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local theta = degToRad(randomFloat(0, 360)) <span class="com">-- random latitude</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local phi = degToRad(randomFloat(-90, 90)) <span class="com">-- random longitude</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local vec = sphericalToCartesian(rad, theta, phi) <span class="com">-- convert to a cartesian coordinate vector</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos = vec <span class="com">-- assign vector to position</span><br>
      end<br><br>
      local function sphereInit()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for i = 1, 5 do<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sphereSpawn()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;end<br>
      end<br><br>
      sphere = createGroup(sphereInit, nil)
    </div>
    Inside of <span class="var">sphereSpawn()</span>, in the lines:
    <div class="code">
      local vec = sphericalToCartesian(rad, theta, phi) <span class="com">-- convert to a cartesian coordinate vector</span><br>
      part.pos = vec <span class="com">-- assign vector to position</span>
    </div>
    we called the <span class="var">sphericalToCartesian()</span> function with arguments <span class="var">rad</span>, <span class="var">theta</span> and <span class="var">phi</span> we defined earlier. The returned vector with cartesian coordinates was saved as <span class="var">local vec</span>. Then we assign <span class="var">vec</span> directly to <span class="var">part.pos</span>, which is possible because <span class="var">vec</span> itself holds a 3D vector object, compatible with <span class="var">part.pos</span>. Of course, since we’re also using <span class="var">emitterIndex</span> to assign an emitter object, <span class="var">part.pos</span> will serve as an offset from the object’s position, hopefully leading to a sphere of particles around the emitter object.<br><br>
    Let’s check out what we ended up with in game.<br><br>
    <img class="fig" src="ch1_5/ch15_sphere1.gif"><br>
    Well, it certainly works and it’s not <i>bad</i>, but I will nitpick about something…<br><br>
    Pay close attention to the density of the particles around the “poles” of the sphere at the top and on the bottom, versus the rest of the sphere. It’s hard to notice, but on average, they appear to be slightly more concentrated near the “poles” than near the “equator”. I think it would look better if the distribution was more even across the whole sphere. To explain how to solve this, we need to first understand why this happens in the first place.<br><br>
    Observe that when you’re closer to the poles of a spherical globe, as you change <span class="var">theta</span> (the longitude), you travel along a much smaller “circle”, compared to when you’re on the equator. In our current formulas for getting a random <span class="var">phi</span> (the latitude), we have an equal chance for any angle between -90 and 90 degrees (-&pi;/2 to &pi;/2 radians):
    <div class="code">
      local phi = degToRad(randomFloat(-90, 90)) <span class="com">-- get random angle between -90 and 90 degrees</span>
    </div>
    This means there is an equal chance to get any latitude, top to bottom. Unfortunately for us, this doesn’t result in an even distribution of points on the sphere, since near the north and south “poles” the points are more clumped together (the perimeter of the circle gets smaller and smaller, but we still have equal chances, regardless of the perimeter). Instead, what we would need to do is calculate an even distribution for the <strong>sine of the latitude angle</strong>, <span class="var">sin(phi)</span>, then “walk backwards” to the corresponding angle value giving said sine value. This makes the playing field more even for all points on the sphere, removing any clumping or bias near the poles.<br><br>
    Therefore, to get rid of the bias / clumping, for <span class="var">phi</span>, we generate a <span class="var">randomFloat()</span> between -1 and 1 and apply the <strong>inverse-sine</strong> function , to obtain an angle between -&pi;/2 to &pi;/2:
    <div class="code">
      local phi = asin(randomFloat(-1, 1))
    </div>
    It may seem like an exercise in futility, as we ended up with angle values in the exact same range as before. However, what changes is the way these angle values are <u>distributed</u> as we go from -&pi;/2 to &pi;/2. Before, there was an equal likelyhood for any value between -&pi;/2 and &pi;/2 to occur, with equal probability. This made the points concentrate at the poles, due to the peculiarities of sphere geometry. However, applying the <span class="var">asin()</span> function makes the angle values more sparse as you approach either pole of the sphere, whereas angles values around the equator have a bigger chance. In principle, this should result in an even distribution of points across the entire sphere surface. Let’s test it again to see if that’s actually the case.
    <div class="code">
      <button class="btn" onclick="copyCode(this)"><span class="tooltip">Copy to clipboard</span><img src="clipboard.png"></button>
      local function sphereSpawn()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(sphere) <span class="com">-- create a particle of the "sphere" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterIndex = getTombIndex(3) <span class="com">-- emitter item with ID 3</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = 60<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeEnd = part.sizeStart * 5<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = randomInt(128, 160)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.g = randomInt(128, 160)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.b = 255<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd = part.colStart<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- spawn on spherical surface</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local rad = 768 <span class="com">-- radius</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local theta = degToRad(randomFloat(0, 360))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local phi = asin(randomFloat(-1, 1))<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local vec = sphericalToCartesian(rad, theta, phi)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos = vec<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 11 <span class="com">-- "shine" sprite texture</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeIn = 15<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeOut = 15<br>
      end
    </div>
    <img class="fig" src="ch1_5/ch15_sphere2.gif"><br><br>
    Although it’s a quite subtle difference, the points appear to spawn more evenly across the sphere now, as evident by the lack of “clumping” around the poles.<br><br>
    We got the result we wanted, but depending on your mathematical skill, all these formulas may seem very “exotic”, and maybe you feel you’re out of your depth. Is there a more convenient way to randomly sample points from a sphere? Yes, there is! The built-in function <span class="var">randomSpherePoint(radius)</span> does this. You just need to supply a <span class="var">radius</span> value, and it will generate a random point (XYZ vector) on a sphere of given radius, centered at the origin point (<span class="var">0, 0, 0</span>). This way, we can replace the entirety of:
    <div class="code">
      local rad = 768 <span class="com">-- radius</span><br>
      local theta = degToRad(randomFloat(0, 360))<br>
      local phi = asin(randomFloat(-1, 1))<br><br>
      local vec = sphericalToCartesian(rad, theta, phi)
    </div>
    with the simplified equivalent:
    <div class="code">
      local rad = 768 <span class="com">-- radius</span><br>
      local vec = randomSpherePoint(rad) <span class="com">-- generate random point on sphere of radius rad</span>
    </div>
    This makes getting the right coordinates even easier, but there is a caveat: this will always take the whole spherical surface into account! In case you want to generate points from only a section of the sphere (like a hemisphere), you have to do it more manually, with the previously described <span class="var">sphericalToCartesian(r, theta, phi)</span> function.<br><br>
    <h4>Spawning inside a sphere volume</h4>
    Okay, so we are able to spawn points on the sphere’s surface, but what about its volume – filling up the sphere with particles? Well, how far the point is away from the center, is determined by the radius value. Let’s do the first thing that comes to mind and simply generate a random radius value from 0 to our max radius 768, with equal distribution:
    <div class="code">
      local r = randomFloat(0, 768) <span class="com">-- random radius</span><br>
    </div>
    If we test this, we again see there’s something not quite right… do you see it?
     <img class="fig" src="ch1_5/ch15_sphere3.gif"><br>
    Most of the points are “clumping” near the core of the sphere and get sparser towards the surface.<br><br>
    We’ve again fallen for yet another trap of mathematics, because this is not the correct way to evenly distribute points within the sphere’s volume. Instead, what we should do is make the point distribution depend on the cube root ∛ (root of degree 3) of the distance from the center. The cube root function in the API is named <span class="var">cbrt()</span>. If we were to apply this cubic root directly to the random radius value:
    <div class="code">
      local r = cbrt(randomFloat(0, 768)) <span class="com">-- not correct!</span>
    </div>
    We will get a much smaller range of values than we would hope for (∛768&nbsp;=&nbsp;9.15771…). Instead of searching for the obscenely large number to place inside the cube root that will reduce itself to our desired radius (for 768 it’s 452984832 – yikes), we can be more clever with some mathematical insight. We will first apply the cubic root to a random float number between 0 and 1 (why this exact range? Notice that ∛0&nbsp;=&nbsp;0 and ∛1&nbsp;=&nbsp;1, which remains the case for any positive exponent and any root degree). Only then, we multiply this cube-rooted random number by 768. This will give us the same results, but we do not have to find weird, spiky numbers for it:
    <div class="code">
      local r = cbrt(randomFloat(0, 1)) * 768 <span class="com">-- cubic root of random float 0 - 1 multiplied by max radius 768</span>
    </div>
    Now, let’s put it all together:
    <div class="code">
      <button class="btn" onclick="copyCode(this)"><span class="tooltip">Copy to clipboard</span><img src="clipboard.png"></button>
      local function sphereSpawn()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(sphere) <span class="com">-- create a particle of the "sphere" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterIndex = getTombIndex(3) <span class="com">-- emitter item with ID 3</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = 60<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeEnd = part.sizeStart * 5<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = randomInt(128, 160)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.g = randomInt(128, 160)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.b = 255<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd = part.colStart<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- spawn in spherical volume</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local r = cbrt(randomFloat(0, 1)) * 768 <span class="com">-- cubic root of random float 0 - 1 multiplied by max radius 768</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local vec = randomSpherePoint(r)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos = vec<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 11 <span class="com">-- "shine" sprite texture</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeIn = 15<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeOut = 15<br>
      end
    </div>
    <img class="fig" src="ch1_5/ch15_sphere4.gif"><br>
    The particles now spawn evenly within the whole volume of the sphere (it is especially noticeable in game).<br><br>
    <h4>Particle spread/charge effect</h4>
    A sphere of motionless particles looks rather boring, but it does give me an idea of how to use it for something more fancy!<br><br>
    What if we made particles cast radially outwards, from the center of a sphere? We can use a vector generated by <span class="var">randomSpherePoint(radius)</span> again, but not for the position of the particle, rather for its velocity this time. Only we have to use a smaller <span class="var">radius</span> than for position, because we are specifying by how much the particle will travel on each game tick (velocity), instead of where the particle is. Meanwhile, for the position itself, we will take advantage of the fact that the default <span class="var">part.pos</span> is <span class="var">(0,&nbsp;0,&nbsp;0)</span>, which combined with <span class="var">part.emitterIndex</span>, makes the particle spawn at the origin of the emitter item.
    <div class="code">
      local speed = 32 <span class="com">-- speed value for the particle</span><br>
      local vec = randomSpherePoint(speed) <span class="com">-- generate a random direction for the particle to move in</span><br><br>
      <span class="com">-- part.pos -- we want the particles moving outwards from the center, hence we use default (0, 0, 0)</span><br>
      part.vel = vec <span class="com">-- particle will travel radially outwards</span>
    </div>
    <img class="fig" src="ch1_5/ch15_sphere5.gif"><br><br>
    This is a nice effect, but what about doing the opposite, i.e. making the particles go towards the center? You know, like in some sort of charging effect for an attack! For example, the Harpy from TR4 has this kind of effect:<br><br>
    <img class="fig" src="ch1_5/harpy.gif"><br>
    The Harpy effect uses line particles, while we will settle for textured sprites. Line particles are definitely possible too, by setting a different <strong>drawing mode</strong> on the particle group. But that is its own separate topic (this plugin is very feature-dense, which makes it difficult to cover concisely) and I don’t want to keep hopping from one train of thought to another every other sentence. We can revisit replicating the Harpy effect once we finally talk about line particles.<br><br>
    We first have to return to using <span class="var">randomSpherePoint(radius)</span> for setting the particle position again, since we want to generate our particles on a sphere. To make the particles then travel towards the center, we can reuse the generated position vector for computing the needed velocity vector, too! To aid this process, we will take advantage of <strong>vector arithmetic</strong>, which is supported by the scripting API in some capacity. I will briefly discuss this now.<br><br>
    Vectors, as you know, have 3 axis components, <span class="var">x, y, z</span>. In vector arithmetic, we are allowed to add (or subtract) two vectors. This is simply done by adding (or subtracting) corresponding components from the vectors:
    <div class="code">
      <span class="com">-- vec1 and vec2 are some XYZ vectors</span><br>
      local vec3 = vec1 - vec2<br>
      <span class="com">-- the resulting vec3 has the following coordinates:<br>
      -- vec3.x = vec1.x - vec2.x<br>
      -- vec3.y = vec1.y - vec2.y<br>
      -- vec3.z = vec1.z - vec2.z
      </span>
    </div>
    We can also multiply a vector by some number (multiplying a vector by a vector will be omitted for now, because there are two very special ways of “multiplying” two vectors). Following similar logic to addition / subtraction, muliplying by a number is simply multiplying each component of the vector by that number:
    <div class="code">
      <span class="com">-- vec1 is a vector value</span><br>
      local vec2 = vec1 * 5<br>
      <span class="com">-- the resulting vec2 has the following coordinates:<br>
      -- vec2.x = vec1.x * 5<br>
      -- vec2.y = vec1.y * 5<br>
      -- vec2.z = vec1.z * 5
      </span>
    </div>
    Okay, but how is this useful? Let’s reason about what we actually want the particle to do. We want the particle to travel from the random sphere point, towards the center of the sphere. We can take advantage of two above statements about vector arithmetic. First, we will figure out the vector that would move the particle from the sphere <u>surface</u> back to the sphere <u>center</u>. Phrased differently, we are calcuating the difference between the position of the particle, which is the vector <span class="var">part.pos</span>, and the sphere center, which we can call <span class="var">center</span>. To obtain the vector <span class="var">diff</span> that would move the particle from <span class="var">part.pos</span> to <span class="var">center</span>, we should subtract <span class="var">part.pos</span> from <span class="var">center</span>:
    <div class="code">
      local diff = center - part.pos
    </div>
    What are the coordinates of <span class="var">center</span>, though? Because we are using <span class="var">emitterIndex</span> relative coordinates, the center of the sphere will be located at <span class="var">(0, 0, 0)</span>, the origin point. If we subtract something from this vector, it’s very much like subtracting a number <span class="var">x</span> from <span class="var">0</span>, where we get its negative, <span class="var">-x</span>. The same happens when subtracting any vector from <span class="var">(0, 0, 0)</span> – we are simply left with the negative of that vector, i.e. <span class="var">(x, y, z)</span> becomes <span class="var">(-x, -y, -z)</span>:
    <div class="code">
      local diff = -part.pos <span class="com">-- negative of part.pos vector</span>
    </div>
    Note that this simplification is only correct if the <span class="var">center</span> vector is indeed <span class="var">(0, 0, 0)</span>, in the general case you must subtract <span class="var">part.pos</span> from <span class="var">center</span> to calculate <span class="var">diff</span> correctly.<br><br>
    We now have the difference vector <span class="var">diff</span>, which added to <span class="var">part.pos</span>, would move the particle back to the center immediately. But we do not want to move the particle immediately, we want it to take its time to move over there. How can we turn <span class="var">diff</span> into a gradual velocity? We can utilize a similar idea as for the <a href="#slowdown">acceleration “slowdown” trick</a>. If <span class="var">diff</span> is the total distance the particle must travel to reach the center, then we must distribute that distance over the particle’s whole lifespan. In other words, the <span class="var">diff</span> vector (<span class="var">-part.pos</span>), divided by the <span class="var">part.lifeSpan</span>, will give us the needed <span class="var">part.vel</span>! There is one small caveat – the scripting API does not support direct division between a vector and a number, only multiplication is allowed. But that is not an issue, if we know our way with mathematics – dividing by some number <span class="var">x</span> is the same as multiplying by its reciprocal <span class="var">1/x</span>, so we can divide vectors by any number (apart from 0, obviously) in that alternative way. We can create a helper variable <span class="var">divider</span> to store the reciprocal, <span class="var">1 / part.lifeSpan</span>, then multiply <span class="var">diff</span> by <span class="var">divider</span>:
    <div class="code">
      local diff = -part.pos <span class="com">-- negative of part.pos vector</span><br><br>
      local divider = 1 / part.lifeSpan<br>
      part.vel = diff * divider <span class="com">-- the distributed velocity</span>
    </div>
    And with that, we can finally reach our goal, a “charging” or “implosion” effect, where the particles vanish as they reach the center:
    <div class="code">
      <button class="btn" onclick="copyCode(this)"><span class="tooltip">Copy to clipboard</span><img src="clipboard.png"></button>
      local function sphereSpawn()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(sphere) <span class="com">-- create a particle of the "sphere" group</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.emitterIndex = getTombIndex(3) <span class="com">-- emitter item with ID 3</span><br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.lifeSpan = 30 * 1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeStart = 60<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.sizeEnd = part.sizeStart * 5<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.r = randomInt(128, 160)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.g = randomInt(128, 160)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colStart.b = 255<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.colEnd = part.colStart<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- spherical "charge" effect setup</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;local r = 1024<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.pos = randomSpherePoint(r)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local diff = -part.pos<br>
      &nbsp;&nbsp;&nbsp;&nbsp;local divider = 1 / part.lifeSpan<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.vel = diff * divider<br><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.spriteIndex = 11 <span class="com">-- "shine" sprite texture</span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeIn = 15<br>
      &nbsp;&nbsp;&nbsp;&nbsp;part.fadeOut = 15<br>
      end
    </div>
    <img class="fig" src="ch1_5/ch15_sphere6.gif"><br>
    Lovely! This is independent of the actual <span class="var">lifeSpan</span> values, meaning this still works if you have a randomized particle life span!
    <hr>
    Well, I’m pretty impressed you’ve made it through the bonus section, thanks for sticking around till the end! I think we have seen enough examples of more elaborate init functions for the time being, although we still may cover other interesting init function techniques, in context of other effect setups. In the meantime, we should carry on with discovering other features of the plugin. I promise you, they are just as cool!<br><br><br>
    <table width=100%>
      <tr>
      <td><a href="Chapter1.html"><strong>&lt;&lt;&lt;&nbsp;PREV</strong></a></td>
      <td style="text-align: right"><a href="Chapter2.html" ><strong>NEXT&nbsp;&gt;&gt;&gt;</strong></a></td>
      </tr>
    </table>
  </body>
</html>
