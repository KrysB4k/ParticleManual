<!DOCTYPE html>
<html>
  <head>
    <title>5 – Particle Groups</title>
  </head>
  <body text=#000000 bgcolor=#FFFFFF link=#0000FF alink=#0000FF vlink=#0000FF>
    <link rel="stylesheet" href="styles.css"/>
    <script src="copycode.js"></script>
    <h1>Particle groups, in-depth</h1>
    <table width=100%>
      <tr>
      <td><a href="Chapter4.html"><strong>&lt;&lt;&lt;&nbsp;PREV</strong></a></td>
      <td style="text-align: right"><a href="Chapter6.html" ><strong>NEXT&nbsp;&gt;&gt;&gt;</strong></a></td>
      </tr>
    </table><br>
    By now, you should be well aware of particle groups as a fundamental element in particle scripting. Recollecting what we have learned about them so far, they serve to classify our created particles into concrete “types”, which have similar behavior and characteristics shared among instances. Particle groups are created with the built-in API function, <span class="var">createGroup(init, update)</span>. Whenever we create a particle group, we may assign an init and update function to it, or pass <span class="var">nil</span> in place of them.<br><br>
    The init function, if specified, is called once on each game tick. It is then responsible for determining how (and under which conditions) particles of the given type are spawned into the game world, on top of giving these particles their initial properties (i.e. <strong>init</strong>ializing the particles). Note that in some circumstances we may spawn these particles through a different method, such as with <a href="Chapter3_5.html#id5">particles spawned by particles</a> in Chapter 3. In these cases, we can specify <span class="var">nil</span> in place of an init function in the <span class="var">createGroup()</span> call, since we will be managing the particle spawning through other means (e.g. directly calling the init function ourselves).<br><br>
    The update function, if specified, is responsible for controlling the particles after being spawned, giving you the ability to code additional custom behavior for particles of a group, beyond what the particle system does with particles in general (updating the position and velocity, size and color, decrementing the life counter). Specifying <span class="var">nil</span> for an update function in the <span class="var">createGroup()</span> call means the particles will not have any special programmed behavior provided by us.<br><br>
    We have not really explored particle groups much beyond that, since the particle effects were the main focus. As it turns out though, particle groups themselves have several fields and properties which further control the characteristics of particles belonging to the group. To avoid ambiguity when talking about group fields and properties alongside mentions of particle instance fields, I will use the convention: <span class="var">group.field</span>, where <span class="var">group</span> is a generic stand-in for a particle group variable, and <span class="var">part.field</span> when talking of fields and properties of particle instances of the group.<br><br>
    In this chapter, we will learn of these more advanced particle group features, which I have skipped over before. Without further ado, let’s get right to it!
    <hr>
    <h2>Sections</h2>
    <strong>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id1">1. Recap on groups, init and update functions</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id2">2. Auto-triggered and manually triggered particles</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id3">3. Saved particles</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id4">4. Particle limits and particle count</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id5">5. Immortal particles</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id6">6. Tethering system</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id7">7. Sprite slot</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id8">8. Sprite blending modes</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id9">9. Sprite drawing modes</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#id10">10. Sprite lighting modes</a><br>
    </strong><br>
    <hr>
    <a name="id1"><h3>Recap on groups, init and update functions</h3></a>
    This far into the tutorials, the drill of creating groups via the <span class="var">createGroup(init, update)</span> function should be clear to you. By calling this function, you are creating a new particle group, i.e. a grouping of particles that share similar characteristics with each other. Among these characteristics is having the same init function and update function. The two placeholder arguments: <span class="var">(init, update)</span> are stand-ins for either the function name variables (respectively for the init function and update function), or the special Lua value, <span class="var">nil</span>. This <span class="var">nil</span> value allows to opt out of specifying a function for a given group. You can omit passing an init function, update function, or even both.<br><br>
    The use-case for omitting (passing <span class="var">nil</span> for) an update function we’ve already seen all the way back in <strong>Chapter 1</strong>. It’s simply when we don’t need our particles being updated or controlled in any special way and the generic update done by the particle system plugin (decreasing life counter, blending colors and sizes) is enough for us. On the other hand, if we want the particles to have some special behavior, beyond the generic plugin-side updates, we must pass an update function which manipulates the particles in our desired way.<br><br>
    Omitting an init function is a bit more nuanced. Here, we can use <span class="var">nil</span> if we don’t want the particles to be spawned into the world autonomously (that is, automatically during the game loop). One such example is if the particles are spawned by other particles. We will pass <span class="var">nil</span> for the init argument in <span class="var">createGroup()</span>, then call the unassigned init function directly, inside the update function of the parent particles. This can be used to make the parent particle leave behind “trails” of child particles (smoke, flames, etc) or have an “aura” of particles around the main parent particle. We omit passing the init function, because we do not want the trail particles to spawn by themselves, as an autonomous effect.<br><br>
    Often, the init function for such child particles involves sending the parent particle instance as an argument to the function (e.g. with the alias name <span class="var">parent</span>), to give the child a reference to the parent particle’s position or some other property (size, color, etc). If we allowed autonomous spawning for the child particle group, the plugin would have no parent particle instance on hand to send to this child init function (and, obviously, the result will be an <span class="var">ERROR</span>, because <span class="var">parent</span> will not exist in this case)!<br><br>
    As the return result of the <span class="var">createGroup()</span> function, we get a particle group value with the specified init and update functions (or lack thereof). We should always assign the group returned from <span class="var">createGroup()</span> to a dedicated local variable we set aside beforehand, near the top of the script.
    <div class="code">
      local group <span class="com">-- local variable for our group</span><br><br>
      <span class="com">-- init, update function definitions</span><br><br>
      group = createGroup(init, update) <span class="com">-- group creation</span>
    </div>
    Notably, the group variable is also what will provide us with access to the properties / fields of the group, which we will learn about soon.<br><br>
    This group-holding variable is then passed as an argument to <span class="var">createSpritePart()</span> or <span class="var">createMeshPart()</span> calls, for creating particles of a given group (which are then further controlled by the provided update function).
    <div class="code">
      <span class="com">-- inside init function</span><br>
      local part = createSpritePart(group) <span class="com">-- creating particle instance of the group</span>
    </div>
    On a technical note, the plugin defers/delays calling the assigned init function until the main game cycle (tick-by-tick progression during a level) is entered, as I pointed out before. Once the game cycle begins, the assignment of the particle group to the variable: <span class="var">group&nbsp;=&nbsp;createGroup(init,&nbsp;update)</span> was already parsed by Lua, making any calls to <span class="var">createSpritePart(group)</span> / <span class="var">createMeshPart(group)</span> valid anywhere inside of the init (or update) function. We will cover the intricacies and other implications later, once we discuss the plugin’s <strong>script phases</strong>.<br><br>
    Our deliberations on particle groups so far have always stopped here – with them having associated init and update functions for controlling particles. Introducing other aspects of particle groups earlier on seemed rather pointless, since it was unnecessary for understanding the basic scripting workflow. As it turns out, there is a whole bunch of extra features associated with particle groups. I have chosen not to get into that topic until now, to avoid unnecessary complexity for basic particle effects in the first chapters. However, as you are now more well-versed in the scripting, I will finally reveal what interesting features were lurking behind particle groups this whole time.<br>
    <hr>
    <a name="id2"><h3>Auto-triggered and manually triggered particles</h3></a>
    The default behavior of particle groups is to have their init functions (specified in the <span class="var">createGroup()</span> call) executed once on each game tick in the main game loop. That’s great, if this is what we want: to have particles spawning on their own, optionally under some simple condition, like once every N-th frame, as we <a href="Chapter1_5.html#interval">have done before</a>.<br><br>
    However, we may also pass <span class="var">nil</span> in place of an init function in the <span class="var">createGroup()</span> call. In this situation, the particle system attempts to call the group’s init function, but because we have set it to <span class="var">nil</span>, it’s more or less the same as if there was an empty init function (which doesn’t do anything) being called instead. Passing <span class="var">nil</span> is just a convenient way of saying “no init function, please”.<br><br>
    Specifying <span class="var">nil</span> can be desired, if the particles are not really forming an independent effect on their own, but are spawned as an add-on or extension to some other effect (like a trail or a halo of a parent particle, e.g. “flames” coming off a projectile). We have worked through this scenario in <strong>Chapter 3</strong>, where the actual spawn function for the trail particles was called in the <a href="Chapter3_5.html#childparts">update function of another particle group</a>, instead of being automatically called by the particle system plugin.<br><br>
    That being said, we can still specify an init function to the group, but then instruct the particle system to not call it automatically, per-tick. Why would such a feature even be needed, if we already can achieve this via <span class="var">nil</span>? Well, in some circumstances, you may want to be able to spawn in individual particles or effects manually, not automatically per each game tick. An example could be particles triggered on demand, via flipeffects or in-game triggers. Yes, controlling particle effects with conventional, in-game triggers is possible!<br><br>
    Particle groups have a field called <span class="var">group.autoTrigger</span>, which decides this behavior: whether or not the group init function gets automatically called in the game cycle loop. It’s a boolean field, with the default value set to <span class="var">true</span>, i.e. the automatic triggering is assumed for the group. When set to <span class="var">false</span>, it will set manual triggering mode, meaning the particle system no longer will call this group’s init function automatically.
    <div class="code">
      group.autoTrigger = false <span class="com">-- group init function does not get auto-triggered by the particle system</span>
    </div>
    After you set the <span class="var">group.autoTrigger</span> field to <span class="var">false</span>, the spawning of these particles is left at your own discretion. How can we spawn the particles, then? One option, which we have examined before, is to manually call the init function somewhere else in your Lua code (such as from the init or update function of another particle group). In this scenario, it’s the same outcome as passing <span class="var">nil</span> for init in the <span class="var">createGroup()</span> call, so this use-case seems rather pointless.<br><br>
    Another possibility for spawning the particles manually is to use <strong>index-bound functions</strong>. Such functions exist for the purpose of triggering particle effects with <strong>Flipeffect 1</strong> from <strong>Plugin_ParticleSystem</strong>.<br><br>
    <h4>Function binding and Flipeffect 1</h4>
    <strong>Flipeffect 1</strong> in <strong>Plugin_ParticleSystem</strong> allows the plugin to call an <strong>index-bound function</strong>. This is an ordinary Lua function, but we will give it a special trait, that allows it to be executed via a Flipeffect trigger. This function doesn’t need any arguments, nor return values. However, the unique aspect is that it gets associated with a chosen <strong>index number</strong> with a special built-in function, <span class="var">bindFunction()</span>.<br><br>
    The <span class="var">bindFunction()</span> function takes two arguments. The first is a numeric integer index, starting from <span class="var">1</span> and counting upwards (up to maximum <span class="var">1024</span>). The second is the Lua function that you would like to bind to the aforementioned index:
    <div class="code">
      local function myFunction()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- first we define what the function should do...</span><br>
      end<br><br>
      bindFunction(1, myFunction) <span class="com">-- then we bind the function to index = 1</span>
    </div>
    Okay, we bound the function <span class="var">myFunction()</span> to index <span class="var">1</span>. What now? Well, let’s read the description of Flipeffect 1 from <strong>Plugin_ParticleSystem</strong>:
    <div class="code">
      Flipeffect 1<br>
      Functions. Invoke Lua function registered with &lt;&amp;&gt; index.
    </div>
    We are now able to trigger the bound Lua function by choosing its index number from Flipeffect 1!<br><br>
    Fine, you might say, but how does this allow us to spawn particles by in-game or script triggers? Well, say we call the desired init function of a group in the registered function:
    <div class="code">
      local function myFunction()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;initFunction() <span class="com">-- call the init function</span><br>
      end
    </div>
    Notice that the init function itself fits the criteria of what is allowed to be a registered Lua function: it has no arguments and returns no values. We might as well register the init function directly, then:
    <div class="code">
      bindFunction(1, initFunction) <span class="com">-- we bind the function to index 1</span>
    </div>
    If you place the trigger for Flipeffect 1 with index 1 selected in the <strong>&lt;&amp;&gt;</strong> timer field and step on it in the level, you will see that the particle gets triggered once every time you step on the tile (due to the default behavior of TRNG triggers)! You can also use Flipeffect 1 as you would any other TRNG plugin trigger, to have particle effects activated within TRNG scripts, allowing some level of interoperability between TRNG and the Lua scripts.<br><br>
    If for some reason you do not have access to the init function used for a particle group (for example, if it’s defined in some external <strong>module script</strong>), there is another way to make the function trigger an init function. It’s yet another built-in function, <span class="var">invokeInit()</span>. That said, I will post-pone talking about it until we get to the ins- and outs of modules.<br>
    <hr>
    <a name="id3"><h3>Saved particles</h3></a>
    You might have already noticed, especially with longer-lasting particles, that when you save the game and reload, any existing particles after reloading are lost (though as long as the init function is active, new ones get spawned in their place). Particles, by default, do not get stored in the save file. This is actually the intended behavior of the plugin, with a simple justification – thousands of particles included in the save will bloat save files quite significantly. If said particles are short-lived and mainly decorative (smoke, dust, flames), there isn’t a good reason to store them in the save file. As long as the the effect is still active (i.e. its init function is being called), the particles should quickly respawn anyway and the players will hardly notice any particles missing for the first few frames after reloading the level.<br><br>
    However, not all particles are decorative, but may serve a significant purpose in the game, such as traps, projectiles, elements of puzzles for game progression, etc. Here, a particle suddenly disappearing due to a save being reloaded can be a disaster, causing serious, game breaking bugs or softlocks that prevent further progress. For this reason, particles CAN be included in save files, with a certain particle group setting.<br><br>
    If you desire a particles of a certain group to get included in savegame data, you must set the particle group field: <span class="var">group.saved</span>. It is a boolean field, set to <span class="var">false</span> by default. Setting it to <span class="var">true</span> will cause all particles of the given group to be saved in save files and restored from the saves after loading, in the exact same state as during the save.
    <div class="code">
      group.saved = true <span class="com">-- allows particles from the group to be stored in save files</span>
    </div>
    A recommendation is to only do this for particle effects that genuinely need save persistence, such as traps or projectiles, or particles with really long lifespans and low spawnrates, which will take several seconds to respawn fully. Remember, lots of particles going into the save data will inflate the save file sizes significantly. Whether that is good or bad, I leave up to you to decide. I am just raising awareness of the consequences.<br><br>
    <h4>Warning on changing scripts and savegame stability</h4>
    The saving feature for particle groups should ideally be enabled as last, after you are finished working on all of the particle effects used for a level. The proper loading of the save files can be guaranteed only if the Lua scripts (this includes level scripts and modules) <u>have not changed</u> between when the save was made and when it is reloaded. In case any changes were made to the level script between saving and loading, the safest option is to delete <u>all</u> of the save files prior to the change and start with fresh saves. I know, this is probably not what you want to hear. Unfortunately, the effects of loading a save file with saved particles, if the script has been altered since making the save, cannot be predicted. This is because the save data made at the time is not aware of any changes made to the script, so it might become incompatible, and thus corrupted, as a result. Reload such save files <u>at your own risk</u>, you have been warned!
    <hr>
    <a name="id4"><h3>Particle limits and particle count</h3></a>
    By default, when you create a particle via the respective API function, the particle instance will be grabbed from a global pool of particles provided by the plugin (there are two distinct pools for sprite particles and mesh particles, on account of them being distinct types of entities). Sometimes, for various reasons, it may be useful to limit the maximum number of particle instances for a specific particle group. Perhaps such particles have a intensive update function which can causes lags if too many particles are around? Or maybe, you want to limit the amount of particles per group when enabling the saving setting described above? Or perhaps you simply want to maintain a strict upper limit of particles of a given type, as otherwise the numerous particles will be cluttering the screen too much.<br><br>
    This implies having something like a dedicated limit of particle instances for a given particle group, rather than relying on the global pool of particles. Indeed, this particle limit feature is available in the plugin! The field <span class="var">group.partLimit</span> allows you to set a positive integer number, which serves to cap the maximum amount of particles that can be active for a given group, at any given time (capping it to that exact number).
    <div class="code">
      group.partLimit = 150 <span class="com">-- set max number of active "group" particles to 150</span>
    </div>
    This will cause <span class="var">group</span> to have a group-specific maximum of 150 particles existing at the same time. If any more particles will attempt to spawn beyond the set limit (either auto-triggered or manually triggered through a direct function call), the logger will emit the following <span class="var">WARN</span> message:
    <div class="code">
      <span style="color:red">warning message placeholder</span>
    </div>
    Of course, the plugin will block creating a new particle instance of this group, until one of the 150 already existing instances becomes inactive (either killed with <span class="var">partKill()</span> or when its <span class="var">part.lifeCounter</span> has naturally decreased to 0), freeing up a spot for a new particle.<br><br>
    <h4>Important: how to properly work with limited particles!</h4>
    I want to make note of an important consequence, which takes place after this limit was reached for some group. The <span class="var">createSpritePart()</span> function call:
    <div class="code">
      local part = createSpritePart(group)
    </div>
    will execute, but return <u>no value</u> (because no new particles are allowed, the limit for this group was already reached). This leaves <span class="var">local part</span> with the <span class="var">nil</span> default value that’s implicit for all unassigned variables. The consequence of this is that indexing of the <span class="var">part</span> variable, e.g.
    <div class="code">
      part.lifeSpan = 100
    </div>
    is now <u>invalid</u>, since <span class="var">part</span> does not carry a particle instance anymore, but the <span class="var">nil</span> value, which has no fields or properties to access. This means one thing: <span class="var">ERROR</span> messages!<br><br>
    So, how do we address this? To prevent such errors from happening, you must <u>first</u> check if the group limit was reached, <u>before</u> attempting to spawn a new particle of the group.<br><br>
    This extra step is mandatory only for particle groups with a set limit value, groups without a set <span class="var">group.partLimit</span> will always return a particle instance (overwriting an existing particle, if necessary), so checking the particle limit is not needed.<br><br>
    You can verify if the particle limit was reached in two ways. The first way is by accessing the read-only field, <span class="var">group.partCount</span>. As you might guess, it holds the number of currently active particles for the given group. This count is updated each game cycle, adding newly spawned particles and removing dead (inactive) ones. You need to compare the <span class="var">group.partCount</span> value against the <span class="var">group.partLimit</span>, prior to calling <span class="var">createSpritePart()</span> (or <span class="var">createMeshPart()</span>), by creating a suitable if-condition gate. This can be accomplished as a new code block gated by an if-condition checking if <span class="var">group.partCount</span> is smaller than <span class="var">group.partLimit</span>:
    <div class="code">
    local group<br><br>
    local function initFunction()<br>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- check if partCount is below partLimit</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;if group.partCount < group.partLimit then<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(group) <span class="com">-- this will make group.partCount increase by 1</span><br><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- e.g. rest of init</span><br><br>
    &nbsp;&nbsp;&nbsp;&nbsp;end <span class="com">-- end of if condition</span><br>
    end <span class="com">-- end of initFunction</span>
    </div>
    Or alternatively, by returning prematurly from the init function, if the <span class="var">group.partCount</span> reached the <span class="var">group.partLimit</span>:
    <div class="code">
    local group<br><br>
    local function initFunction()<br>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- check if partCount exceeded partLimit</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;if group.partCount >= group.partLimit then<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return <span class="com">-- return function early, without creating part</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;end<br><br>
    &nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(group) <span class="com">-- this will make group.partCount increase by 1, towards the limit</span><br><br>
    &nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- e.g. rest of init</span><br><br>
    end <span class="com">-- end of initFunction</span>
    </div>
    There is also one more option, which could be more convenient (depending on your preferences): the <span class="var">checkPartLimit()</span> built-in function. It takes the group as an argument and returns the boolean <span class="var">true</span> if the <span class="var">group.partLimit</span> has NOT been reached yet. Otherwise, the function returns <span class="var">false</span>. In case an expression (e.g. function call) results a boolean, Lua allows to omit the explicit comparison of the boolean value to <span class="var">true</span> or <span class="var">false</span> (the comparison is redundant when the expression results in a boolean value):
    <div class="code">
    local group<br><br>
    local function initFunction()<br>
    &nbsp;&nbsp;&nbsp;&nbsp;if checkPartLimit(group) then <span class="com">-- implictly check for true boolean</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local part = createSpritePart(group)<br><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="com">-- e.g. rest of init</span><br><br>
    &nbsp;&nbsp;&nbsp;&nbsp;end <span class="com">-- end of if condition</span><br>
    end <span class="com">-- end of initFunction</span>
    </div>
    Either of the three examples achieve the same thing, which is no attempts of spawning more particles, when <span class="var">group.partLimit</span> has been reached.<br><br>
    You can write your code in whichever way you choose, so take this suggestion with a grain of salt. I just want to highlight that the code structure and readability could be improved with modularizing: isolate the particle initialization itself to a separate, dedicated function and leaving the decision whether to call it to the “master” init function (if you remember, we have done something rather similar in context of the <a href="Chapter1_5.html#newfunc">spawnrate modification</a>, where this function modularization was first demonstrated).<br>
    <div class="code">
    local group<br><br>
    local function initFunction()<br>
    &nbsp;&nbsp;&nbsp;&nbsp;if checkPartLimit(group) then <span class="com">-- implictly check for true boolean</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spawnParticle(group) <span class="com">-- call separate spawning function</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;end <span class="com">-- end of if condition</span><br>
    end <span class="com">-- end of initFunction</span>
    </div>
    <hr>
    <a name="id5">Immortal particles</a>
    By default, all particles have a finite life-span, meaning they exist for a specified amount of time, before becoming dead/inactive (the particle system then “recycles” them, whenever a new particle instance is requested). Besides that,If you tried to test the limits of the plugin by spawning thousands of particles, you will see that the plugin, after reaching the upper (global) limit of particles, proceeds to also “recycle” the particles that were already spawned, but were still active. This is intended behavior, as the plugin has a fixed, finite amount of particles it manages.<br><br>
    For most particle effects, this is not a big deal, that some small particle got recycled. However, the intention of this plugin is to make the particles very general-purpose. And perhaps the particle you are spawning has some important purpose that is necessary for
    <hr>
    <a name="id6"><h3>Tethering system</h3></a>
    The <span class="var">part.emitterIndex</span> and <span class="var">part.emitterNode</span> fields, if you remember, allowed to <a href="Chapter1_5.html#id2">spawn particles around moveables</a> or <a href="Chapter1_5.html#id3">near specific meshes</a> of said moveables. This changed the particle spawn positions to be relative to the moveable / mesh, so a <span class="var">part.pos</span> like <span class="var">(x: 256, y: -512, z: 1024)</span> would make the particle position an offset from the object / mesh, instead of it appearing at the world coordinates (X: 256, Y: -512, Z: 1024). However, I alluded to this being only part of the full story behind this feature. Well, the time has come to reveal this full story, so get a cup of coffee or tea and take a comfy seat!<br><br>
    <h4>How emitterIndex / emitterNode <i>really</i> work</h4>
    The <span class="var">emitterIndex</span> and <span class="var">emitterNode</span> properties are an integral element of the plugin’s <strong>moveable tethering system</strong> for particles. The tethering system allows particles to be constrained, temporarily or indefinitely, to a specific moveable index via <span class="var">emitterIndex</span>, or furthermore, to a mesh of said moveable via <span class="var">emitterNode</span>. This constraint makes the particle’s coordinate system relative to the chosen moveable / mesh. The duration of the constraint is determined by something known as a <strong>cutoff point</strong>. If a particle has been alive for longer than the number of game frames specified by the cutoff point, the particle gets released from the moveable (<span class="var">emitterIndex</span> and <span class="var">emitterNode</span> both get set to <span class="var">-1</span>, their default value) and the coordinate system of the particle becomes global (which is the default state of particles).<br><br>
    The default duration of the <strong>cutoff point</strong> is 0 game ticks. This means that the particle bearing some <span class="var">emitterIndex</span> / <span class="var">emitterNode</span> gets released immediately after being spawned at the relative coordinates given to it, once the plugin exits out of the init function. This makes for a convenient way to have the particle spawn in proximity of the emitting moveable. This default cutoff point of 0 is what we have been taking advantage of this whole time, when “emitting” particles from moveables. The particles are getting instantly freed from the moveable after the init function exits, thus “spawning around the moveable”, without having to specify global coordinates in the level map. Clever, right?<br><br>
    But what if we extend the cutoff point beyond 0, so that the particle is not released immediately? The particle will maintain its relativity to the object, even if the object <strong>itself</strong> is being moved around in the game world (e.g. an enemy running around, or an Animating moved by TRNG scripts). It makes the particle stick to the emitter’s frame of reference, until the time indicated by the cutoff point elapses. If the cutoff point is greater or equal to the particle’s <span class="var">lifeSpan</span>, the particle remains tethered to the moveable indefinitely (i.e. for as long as it’s alive).<br><br>
    <h4>The airplane analogy</h4>
    To give an illustrative analogy for the tethering system and the particles moving with the moveable’s frame of reference, imagine passengers flying in an airplane. The passengers are the particles, while the airplane is the moveable given by <span class="var">emitterIndex</span>. The cutoff point in this analogy is the duration of the flight. As a passenger (particle), you are free to roam around the aircraft (moveable). In theory, you could walk, run, jump around just like back down on Earth (though the flight attendants may not appreciate such erratic behavior on a commercial flight, but let’s ignore that). Simultaneously, by proxy of being in the aircraft, you are also soaring across the sky at several hundreds of kilometers/miles per hour! So, you can move around the plane deck, all while zipping through the air at high speeds, by virtue of the plane flight. Therefore, your movement, when viewed from outside the aircraft, is a net sum of the motion imparted on you by the aircraft, plus any motion you do yourself on board the plane.<br><br>
    In a similar way, the particles constrained to moveables move together with the moveable, as one unit. The <span class="var">pos</span> vector is thus relative to the position of the <span class="var">emitterIndex</span> moveable. At the same time, the particles can also have additional motion independent of the moveable, through their velocity vector <span class="var">vel</span>. Only once the cutoff point is reached, they lose this constraint to the moveable’s frame of reference. Of course, the airplane analogy is not perfect, as the particle can travel even far outside the vicinity of the tethering moveable, wheareas as a passenger of the airplane, you are confined to the plane deck and cannot travel outside of it, at least not without losing the constraint of the aircraft midair (in which case, you better have a parachute with you)! Nevertheless, the analogy still conveys the essence of the tethering system. Now, we’ll get into the Lua specifics of the tethering system in the plugin.<br><br>
    <h4>The attach field (and its cutoff and random sub-fields)</h4>
    All things related to the tethering system are controlled by the field <span class="var">group.attach</span> (this means that the tethering settings are controlled on the particle group level as a whole, rather than on individual particle instances). The <span class="var">attach</span> field is further comprised of a few sub-fields itself. Among them are the the <span class="var">group.attach.cutoff</span> field, the <span class="var">group.attach.random</span> field and the <span class="var">group.attach.tetherType</span> field. Let’s describe the first two, as they are closely related in operation.<br><br>
    The <span class="var">cutoff</span> component field of <span class="var">group.attach</span> is the cutoff point, explained earlier. It decides the point in the particle lifetime, at which the “airplane flight trip” is over, i.e. when the particle ceases attachment to the moveable and starts moving completely independent of it. It is an integer number field and the range of accepted values is identical as for <span class="var">part.lifeSpan</span> / <span class="var">part.lifeCounter</span>, i.e. <span class="var">0</span> to <span class="var">32767</span>. Its default value is set to <span class="var">0</span>. Aside from these numeric values, the field accepts a special <span class="var">NO_CUTOFF</span> constant.<br><br>
    Non-zero values delay the point at which the particles detach themselves from the <span class="var">emitterIndex</span> moveable. If a cutoff point is set to a value of <span class="var">100</span>, it means that once a particle reaches a life duration of 100 game frames (notice that this is when <span class="var">part.lifeSpan - part.lifeCounter</span> is equal to 100, due to the <span class="var">lifeCounter</span> counting down to 0), it will get detached from the moveable.<br><br>
    What if the particle has a <span class="var">lifeSpan</span> shorter than <span class="var">100</span>? Simple, in this case it will never get detached from the moveable for as long as it’s alive. This means that it is possible to set a cutoff value which makes particles attach for their entire lifespan. Setting <span class="var">cutoff</span> with special constant <span class="var">NO_CUTOFF</span> ensures this will always be the case, regardless of the individual <span class="var">lifeSpan</span> value is for each particle of the group (the constant is always larger than the maximum possible <span class="var">lifeSpan</span> value).
    <div class="code">
      group.attach.cutoff = NO_CUTOFF <span class="com">-- ensures that the particles always remain attached to the moveable</span>
    </div>
    Notice that if you give the group a cutoff value like <span class="var">100</span>, and the particles live longer than that, all of the particles will detach at the same point of their life. For some cases, this is desired, but perhaps not always. In some circumstances, it might be preferable if each particle detaches at a slightly different (randomized) time.<br><br>
    This is what the <span class="var">random</span> field is for. By default, its value is also set to <span class="var">0</span>. What <span class="var">random</span> does is it generates a random integer between <span class="var">0</span> and a maximum set by the value of <span class="var">random</span>. This random integer value is unique and constant for each particle, meaning it doesn’t change throughout the specific particle’s lifetime (one particle always gets 5, another particle always gets 9, etc). Then, this random integer gets added to the cutoff point for that particle. As a result, this will make different particles detach at different times, the effective cutoff point being somewhere in the range (<span class="var">cutoff</span>, <span class="var">cutoff + random</span>).<br><br>
    Here’s a specific example:
    <div class="code">
      group.attach.cutoff = 20<br>
      group.attach.random = 10
    </div>
    We have a <span class="var">cutoff</span> set to 20 and a <span class="var">random</span> set to <span class="var">10</span>. This will mean that the particles of the particle group <span class="var">group</span> will get detached at a randomized cutoff point between <span class="var">20</span> (<span class="var">cutoff</span>) and <span class="var">30</span> (<span class="var">cutoff + random</span>). For example, the detach points for individual particle instances could be: <span class="var">27, 23, 22, 29, 24, 22, 30, 27, 20, 23...</span><br><br>
    <h4>The tether type</h4>
    The <span class="var">group.attach</span> Now we’ll talk about the <span class="var">tetherType</span> component field of <span class="var">attach</span>. The <span class="var">tetherType</span> controls the way in which the tether of a particle works. As was explained in the airplane analogy, tethered particles inherit their motion from the moveable to which they are tethered to. However, the precise details of how the motion is inherited depends on this <span class="var">tetherType</span> setting. There are three <span class="var">TETHER_</span> constants, corresponding to the 3 possible options:<br><br>
    <table cellpadding = "15" cellspacing = "15" class="tab">
      <caption>Tether type constants</caption>
      <tr>
        <th><strong>Numeric Index</strong></th>
        <th><strong>TETHER_ Constant</strong></th>
        <th><strong>Description</strong></th>
      </tr>
      <tr>
        <td><span class="var">0</span></td>
        <td><span class="var">TETHER_ROTATING</span></td>
        <td>The coordinate system of particles factors in the rotational motion of a given moveable / mesh, along with the position. <strong>This is the default tethering mode.</strong></td>
      </tr>
      <tr>
        <td><span class="var">1</span></td>
        <td><span class="var">TETHER_STATIC</span></td>
        <td>The coordinate system of particles ignores the rotations of a moveable / mesh, only the changes to the moveable / mesh position are respected.</td>
      </tr>
      <tr>
        <td><span class="var">2</span></td>
        <td><span class="var">TETHER_NONE</span></td>
        <td>This mode effectively makes the particles behave as if they were detached, following the global coordinate system. In spite of this, it keeps track of the moveable (<span class="var">emitterIndex</span>) / mesh (<span class="var">emitterNode</span>) until reaching the cutoff point.</td>
      </tr>
    </table><br><br>
    The <span class="var">TETHER_ROTATING</span> and the <span class="var">TETHER_STATIC</span> tether types differ in how the moveable to which the particles are tethered affects the coordinate system of the particle. A rotating tether respects the rotation of the moveable, meaning if the moveable, or any of its meshes, rotate during animations or otherwise, the particle’s frame of reference rotates along with the moveable or mesh, on top of being displaced by the changes in the moveable’s position. The static tether disregards the rotation effects and only respects the changes in position. These tether effects are quite difficult to explain and even demonstrate outside of the game itself, so my only suggestion is to try both of them out and observe the difference yourself.<br><br>
    The <span class="var">TETHER_NONE</span> is unique in that there is no effect on the particle’s frame of reference, the particle will follow the global coordinate system (i.e. the position is not relative to the moveable in any way). Regardless, the particle does not lose reference to the <span class="var">emitterIndex</span> moveable, at least not until the cutoff point is reached. This results in the “tether” between the particle and the <span class="var">emitterIndex</span> to become a more abstract concept, not a physical one. This even allows to invert the tethering relationship between the particle and the moveable, where the particle itself moves freely and through an update function, moves the moveable item around itself. Admittedly, though, this is a very advanced, niche scenario with few applications.<br><br>
    <h4>Manually tethering and untethering particles</h4>
    To conclude this section, I will add that there are special particle functions which allow you to manually detach and (re)attach particles to moveables. These are the <span class="var">partDetach()</span> function, which untethers the given particle, and <span class="var">partAttach()</span>, which allows to tether (attach) a particle onto a moveable. Remember, even if the particle group has a rotating or static tether type and a cutoff set to <span class="var">NO_CUTOFF</span>, the particles belonging to the group will not be attached to any moveable if no <span class="var">part.emitterIndex</span> is given (because it is set to <span class="var">-1</span> by default). This allows particles, initially untethered, to attach themselves to a moveable at a later stage in life, or start attached to one moveable and attach to another moveable later. Reminder that the cutoff value is a global setting for the particle group itself, not individual particle instances. You cannot change the value of the cutoff during runtime, so if you intend to manually link and unlink your particles from moveables, it may make more sense to set <span class="var">NO_CUTOFF</span> anyway.<br><br>
    An example usage for this manual tethering could be making a napalm flamethrower weapon. The burning “napalm” particles, upon colliding with an enemy or Lara, can be manually attached to the moveable in the update function, i.e. sticking to and following the moveable. However, this is a very advanced feature of the tethering system for highly specific cases. You can read up more on both <span class="var">partAttach()</span> and <span class="var">partDetach()</span> functions in the scripting reference on built-in functions.<br>
    <hr>
    All the fields and settings of particle groups mentioned up to this point were applicable to both types of particles (sprite and mesh). The fields that will be described below, however, are unique to sprite particles. You could set them on a group that deals with mesh particles of course, but it will simply have no effect for them.
    <hr>
    <a name="id7"><h3>Sprite slot</h3></a>
    Sprite particles, as you already know, have the <span class="var">part.spriteIndex</span> field for specifying the index of the sprite texture to use for the current particle instance. By default, these sprite textures are taken from none other than the <strong>DEFAULT_SPRITES (463)</strong> slot. This slot already contains many sprite textures that are used for vanilla effects. It’s of course possible to add custom sprite textures beyond the default 33 textures present in the <strong>DEFAULT_SPRITES</strong> object, but maybe you prefer to store your custom sprite textures in a separate sprite slot, while keeping the original <strong>DEFAULT_SPRITES</strong> intact (or to separate these textures in a more meaningful way).<br><br>
    You can use two other sprite slots for sprite particles, the <strong>MISC_SPRITES (464)</strong> slot and the <strong>CUSTOM_SPRITES (494)</strong> slot added with TRNG (<strong>NG custom sprites</strong>, as they are labeled in the Tomb Editor toolset). You can have all three slots in a single level of course, but each particle group can have only one of them assigned, determining which sprite set the <span class="var">part.spriteIndex</span> will point to.<br><br>
    To change which of these slots the sprite particles will take textures from, you must change the slot ID on the particle group, via the <span class="var">group.spriteSlot</span> field. There are three acceptable values for this field: <span class="var">463</span> for <strong>DEFAULT_SPRITES</strong>, <span class="var">464</span> for <strong>MISC_SPRITES</strong> and <span class="var">494</span> for <strong>CUSTOM_SPRITES</strong>. You do not have to memorize these ID numbers, you may also use the corresponding <span class="var">SLOT_</span> constants instead:
    <div class="code">
      group.spriteSlot = SLOT_DEFAULT_SPRITES <span class="com">-- sets 463, the default option</span><br><br>
      group.spriteSlot = SLOT_MISC_SPRITES <span class="com">-- sets 464 for the MISC_SPRITES slot</span><br><br>
      group.spriteSlot = SLOT_CUSTOM_SPRITES <span class="com">-- sets 494 for the CUSTOM_SPRITES slot</span>
    </div>
    Assigning an index or <span class="var">SLOT_</span> constant for a non-sprite slot (e.g. <span class="var">437</span> / <span class="var">SLOT_ANIMATING6</span>) will set <span class="var">group.spriteSlot</span> to the <span class="var">SLOT_DEFAULT_SPRITES</span> value (463), along with a logger warning.<br><br>
    The protective measures for the <span class="var">part.spriteIndex</span> field exist for all 3 sprite slots, meaning that it is impossible for the <span class="var">spriteIndex</span> go beyond the highest index of sprite texture in the given sprite slot. Attempting to go past the maximum index will clamp the value and send the appropriate warning in the logger. The chosen sprite slot must include at least 1 sprite texture for it to work properly (though this seems rather obvious).<br>
    <hr>
    <a name="id8"><h3>Sprite blending modes</h3></a>
    Remember when I quickly alluded to <a href="Chapter1.html#blend">different blending modes</a> when we talked about sprite particle colors back in Chapter 1? For example, to enable particles to have dark or black colors, instead of being invisible? Well, time to finally talk about it!<br><br>
    The blending modes are a particle group setting, accessed by the <span class="var">group.blendMode</span> field. The values you can use here are numeric indices of the blending modes used internally by the Tomb4 engine. These are also the blending mode numbers used in the FLEP <strong>Smoke emitter white OCB setting</strong> patches and precisely correspond to the <strong>New blending modes</strong> patch for enabling extra blending modes for the engine. However, since it can be difficult to memorize which numeric index corresponds to which blending mode, the plugin has special <span class="var">BLEND_</span> constants to be used in the scripts, possessing the index value of their corresponding blending mode. Below is a table listing the indices of the available blending modes, the BLEND_ constants used in scripts and the description of what the blending mode does. Reminder that to be able to use all of these modes, starting from 5 onwards, you <u>must</u> have the <strong>New blending modes</strong> patch enabled in FLEP.<br><br>
    <table cellpadding = "15" cellspacing = "15" class="tab">
      <caption>Blending modes list</caption>
      <tr>
        <th><strong>Numeric Index</strong></th>
        <th><strong>BLEND_ Constant</strong></th>
        <th><strong>Description</strong></th>
      </tr>
      <tr>
        <td><span class="var">0</span></td>
        <td><span class="var">BLEND_TEXTURE</span></td>
        <td>Opaque. No transparency allowed, magenta(255, 0, 255) turns to black(0, 0, 0).</td>
      </tr>
      <tr>
        <td><span class="var">1</span></td>
        <td><span class="var">BLEND_DECAL</span></td>
        <td>Opaque. Magenta(255, 0, 255) is fully transparent, other colors (incl. pure black(0, 0, 0)) are rendered as-is.</td>
      </tr>
      <tr>
        <td><span class="var">2</span></td>
        <td><span class="var">BLEND_COLORADD</span></td>
        <td>Transparent additive blending. Pure black(0,0,0) is transparent, opaqueness increases with brighter colors and overlapping. <strong>This is the default blending mode.</strong></td>
      </tr>
      <tr>
        <td><span class="var">3</span></td>
        <td><span class="var">BLEND_SEMITRANS</span></td>
        <td>Opaque. Pure black(0,0,0) and magenta(255, 255, 255) are invisible. Any 3D geometry “behind” the sprite gets “coated” by the texture, leaving just the silhouettes visible.</td>
      </tr>
      <tr>
        <td><span class="var">4</span></td>
        <td><span class="var">BLEND_NOZBUFFER</span></td>
        <td>Like <span class="var">BLEND_DECAL</span> but ignores the Z-depth buffer, meaning particles get always rendered, even if they are “behind” geometry.</td>
      </tr>
      <tr>
        <td><span class="var">5</span></td>
        <td><span class="var">BLEND_COLORSUB</span></td>
        <td>Transparent subtractive blending. Opposite of BLEND_COLORADD, sprite colors are inverted (bright becomes dark). Pure black(0,0,0) is transparent.</td>
      </tr>
      <tr>
        <td><span class="var">6</span></td>
        <td>none</td>
        <td>Reserved for drawing line particles, do not use.</td>
      </tr>
      <tr>
        <td><span class="var">7</span></td>
        <td><span class="var">BLEND_SEMITRANS_ZBUFFER</span></td>
        <td>Opaque. More research needed.</td>
      </tr>
      <tr>
        <td><span class="var">8</span></td>
        <td><span class="var">BLEND_DESTINATION_INV</span></td>
        <td>Transparent. Destination inversion, meaning that colors “behind” the sprite are inverted (bright becomes dark). Pure black (0,0,0) is transparent.</td>
      </tr>
      <tr>
        <td><span class="var">9</span></td>
        <td><span class="var">BLEND_SCREEN_DARKEN</span></td>
        <td>Transparent. Screen darken.</td>
      </tr>
      <tr>
        <td><span class="var">10</span></td>
        <td><span class="var">BLEND_SCREEN_CLEAR</span></td>
        <td>Transparent. Screen clear.</td>
      </tr>
      <tr>
        <td><span class="var">11</span></td>
        <td><span class="var">BLEND_CUSTOM_11</span></td>
        <td>Custom mode 11 (see <strong>New blending modes</strong> FLEP patch).</td>
      </tr>
      <tr>
        <td><span class="var">12</span></td>
        <td><span class="var">BLEND_CUSTOM_12</span></td>
        <td>Custom mode 12 (see <strong>New blending modes</strong> FLEP patch).</td>
      </tr>
      <tr>
        <td><span class="var">13</span></td>
        <td><span class="var">BLEND_CUSTOM_13</span></td>
        <td>Custom mode 13 (see <strong>New blending modes</strong> FLEP patch).</td>
      </tr>
    </table><br><br>
    Each blending mode has unique interactions with the source (the sprite texture) and the destination (the background behind the sprite). Some of these blending modes are more useful than others. Some behave in unexpected ways. If you have the required knowledge, can also set custom blending modes: 11, 12, and 13, via the <strong>New blending modes</strong> FLEP patch.<br><br>
    Blending modes are only applicable to sprite particles. On mesh particles, they have no effect, since the source mesh is already textured in a certain way.<br>
    <hr>
    <a name="id9"><h3>Sprite drawing modes</h3></a>
    Aside from blending modes for sprites, we also have drawing modes. Drawing modes determine what the renderer should draw, given the input. You might say – <i>“Well, these are sprite particles, so it should draw sprites!”</i> – and I agree with this sentiment. However, you may remember than in the Tomb4 there is a specific kind of particle – a thin line streak, oriented in the direction the particle is travelling in, optionally with a color. You see this subtype of particle with water drips when Lara gets out of water, rain drops, ricochets on walls when firing guns, and perhaps other examples I am forgetting about. These are called <strong>line particles</strong>. Apart from the somewhat different rendering approach, the engine treats them identically to ordinary sprite particles.<br><br>
    We could not skip out on making these line particles available for the particle plugin as well. How do you create them in the Particle System plugin? By setting the appropriate <strong>draw mode</strong> for the particle group!<br><br>
    The draw mode setting is a field fittingly called <span class="var">group.drawMode</span>. There are 5 draw modes currently available in the plugin. Similarly to blending modes, they are numeric indices, but they come with handy <span class="var">DRAW_</span> constants for convenience. They are listed in the table below:<br><br>
    <table cellpadding = "15" cellspacing = "15" class="tab">
      <caption>Drawing modes list</caption>
      <tr>
        <th><strong>Numeric Index</strong></th>
        <th><strong>DRAW_ Constant</strong></th>
        <th><strong>Description</strong></th>
      </tr>
      <tr>
        <td><span class="var">0</span></td>
        <td><span class="var">DRAW_SPRITE</span></td>
        <td>Draws the sprite with the texture given by <span class="var">part.spriteIndex</span>. <strong>This is the default drawing mode.</strong></td>
      </tr>
      <tr>
        <td><span class="var">1</span></td>
        <td><span class="var">DRAW_SQUARE</span></td>
        <td>Ignores the <span class="var">part.spriteIndex</span> texture, drawing just a blank (textureless) square / rectangle.</td>
      </tr>
      <tr>
        <td><span class="var">2</span></td>
        <td><span class="var">DRAW_LINE</span></td>
        <td>Draws a thin line streak in place of a square. The length of the streak depends on the velocity vector and size of the particle.</td>
      </tr>
      <tr>
        <td><span class="var">3</span></td>
        <td><span class="var">DRAW_ARROW</span></td>
        <td>Similar to DRAW_LINE but adds an arrowhead in the direction the particle is moving in.</td>
      </tr>
      <tr>
        <td><span class="var">4</span></td>
        <td><span class="var">DRAW_NONE</span></td>
        <td>Does not render the particle (but it still remains active e.g. for the update function).</td>
      </tr>
    </table><br><br>
    We see that we have some interesting entries in the table. They can be grouped into three general categories based on similarities.<br><br>
    <h4>DRAW_SPRITE and DRAW_SQUARE</h4>
    <span class="var">DRAW_SPRITE</span> and <span class="var">DRAW_SQUARE</span> both draw the particle square/rectangle, respecting the blending mode set for the particle. <span class="var">DRAW_SPRITE</span> also uses the texture indicated by the part’s <span class="var">spriteIndex</span>, whereas <span class="var">DRAW_SQUARE</span> ignores it, leaving the square blank. This results in the same as having a solid white square as a sprite texture.<br><br>
    <h4>DRAW_LINE and DRAW_ARROW</h4>
    <span class="var">DRAW_LINE</span> and <span class="var">DRAW_ARROW</span> work differently, in that a line segment is drawn between the current <span class="var">pos</span> vector of the particle and a projection away from the <span class="var">pos</span> vector by a fraction of a the <span class="var">vel</span> vector. Perhaps this does not immediately make sense, but in layman’s terms, this means that the position of the line segment depends on the <span class="var">part.pos</span> vector, while the length of this segment depends on the particle’s current velocity and current size (either the blended size between <span class="var">sizeStart</span> and <span class="var">sizeEnd</span> or the overridden <span class="var">sizeCust</span>). I’ve made a little interactive demo of this idea, which will perhaps get the meaning across better than any explanations I could come up with.<br><br>
    Anyway, the implication of this is that line particles will not get drawn if the velocity is 0 (that is, each <span class="var">x y z</span> component is 0), even if the size is huge. There is an exception to this, however. There is a boolean field of groups, called <span class="var">lineIgnoreVel</span>. If this field is set to <span class="var">true</span>, the lines are instructed to ignore the velocity contributing to the length of the line segment.
    <div class="code">
      group.lineIgnoreVel = true
    </div>
    In this case, the length of the line segment will be determined exclusively from the current size of the particle. A consequence of this, the direction of the line segment at 0 velocity cannot be uniquely defined, hence it may look random or buggy (which is an unavoidable tradeoff if you set <span class="var">lineIgnoreVel</span> to <span class="var">true</span>).<br><br>
    Line particles ignore the <span class="var">spriteIndex</span>, <span class="var">sizeRatio</span>, <span class="var">rot</span> and <span class="var">rotVel</span> sprite particle fields. Additionally, they ignore the blending mode setting, as there is a single, reserved blending mode for line particles, which is always additive color blending (i.e. pure black(0,0,0) is transparent).<br><br>
    <h4>DRAW_NONE</h4>
    Perhaps you have read the description of this draw mode and are confused by it. What is the purpose of going through the trouble of defining a particle group, then giving it the <span class="var">DRAW_NONE</span> drawing mode? Not drawing the particles just seems to make no sense, either you have the particles rendered or don’t bother, right? However, I now want to convince you that these “invisi-particles”, as I like to call them, can be surprisingly useful in unexpected ways.<br><br>
    If we strip away all graphical qualities of a particle, what are we left with? We have the base properties of the particle: the <span class="var">pos</span>, <span class="var">vel</span>, <span class="var">accel</span> vectors, the <span class="var">lifeSpan</span> and <span class="var">lifeCounter</span>. On top of that, we also have an init function and update function tied to the particle group of said particles.
    We thus have an entity with a duration (lifetime), position, optionally a velocity and acceleration too. We can determine how this invisible entity spawns with the init function, then control what it does with the update function. These “invisi-particles” are not rendered themselves, but thanks to having a position and velocity, can become a moving “canvas” for other, subsidiary effects taking place via the update function. This canvas can also be attached to specific entities, via the <span class="var">emitterIndex</span> / <span class="var">emitterNode</span> tethering system. This invisi-particle has a limited duration, dying after a certain amount of time. You can still do anything non-graphical with such a curious particle in the update function – it can work as a “pilot” or “manager”, that carries other effects with it or instructs child particles what to do. Putting things in TRNG terms, it can work as a localized, travelling Organizer / GlobalTrigger hybrid, which you can spawn anywhere and control via the update function, possibly carrying other particles along with it!<br><br>
    A practical example of this, which will be shown in a later chapter, is having an invisi-particle attached to a baddy via the <span class="var">part.emitterIndex</span>, with its update function triggering flame sprite child particles to appear on the baddy’s meshes at random, all while decrementing the hitpoints of the attached enemy per game tick. This will cause the enemy to burn and evetually, die, just like Lara does! Another application of this is reimplementing the TRLE explosion effect with the Particle Scripting API (which involves delayed spawing of fire / smoke particles at a certain location). In fact, this was already done as one of the module script templates available in example script repository. Hopefully, this shows you some of the potential that “invisi-particles” can have, if you view them as localized entities under scripting control.<br>
    <hr>
    <a name="id10"><h3>Sprite lighting modes</h3></a>
    <hr>

  </body>
</html>
